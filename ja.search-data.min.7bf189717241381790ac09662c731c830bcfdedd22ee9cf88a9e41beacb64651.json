[{"id":0,"href":"/ja/CONTRIBUTING/","title":"Contributing","section":"","content":" AIネイティブ開発ガイドに貢献する # GitHub Copilot パターン\u0026amp;エクササイズ ワーキンググループの目標は、AIネイティブ開発のベストプラクティスを収集、文書化、および公開することです。ベストプラクティスを理解しやすく、評価しやすく、適用しやすくするために、私たちはそれらを特定の構造に符号化します。\nこのワーキンググループが活発に活動するために、小さな貢献でも大きな貢献でも、皆さんの参加を歓迎します。\nコントリビューションをする方法 # GitHub Copilot パターン\u0026amp;エクササイズへの貢献を検討している方へ、以下はどのように貢献できるかについての提案です。\n意見を共有し、議論を促す: 新鮮な視点、興味深い考え、または初期の斬新なアイデアは、議論を引き起こし、予測できない結果を生み出すことがあります。AIネイティブ開発関連のトピックについていつでも Issues を作成して意見を共有するようにお願いします。 既存のパターンを読み、改善する: 始めるには、このリポジトリの既存のパターンや資料を読むことをお勧めします。誤解を招くフレーズやまずい文法を見つけましたか？コンテンツの誤り？GitHub Issue を作成するか、直接プルリクエストとして修正を提案してください。 パターンを使用していることを確認する: 複数の組織がパターンを使用していることを確認すると、そのパターンの関連性が高まり、他の採用者にこのパターンが実証済みであることを知らせることができます。公開されているパターンのいずれかを使用している場合は、そのパターンに既知のインスタンスとして組織をリストし、それ適用した際の経験について説明してください。 既存のパターンを翻訳する: あなたの地域でAIネイティブ開発の実践を導入する際、ほとんどのAIネイティブ開発のコンテンツが英語で利用可能であるため、言語の障壁が人々にとって問題になることがあります。そのため、あなたの地域/組織の人々が自分たちの言語でAIネイティブ開発を理解できるようにすることは大変価値があります。パターンを他の言語に翻訳する方法については、翻訳手順を参照してください。 オープンなプルリクエストをレビューする: パターンワーキンググループのすべての詳細を知らなくても、既存のプルリクエスト（特にパターン内容の変更を提案するもの）に対するフィードバックは、その著者にとって有益です。 AIネイティブ開発を学びたい人として、将来の読者の視点から意見を述べることができます。独自のAIネイティブ開発経験を持つ人として、著者と経験を共有することができます。 新しいパターンに貢献する: あなたができる主要な貢献は、経験したり知っているAIネイティブ開発のベストプラクティスを文書化することです。 このリポジトリのコンテンツには、異なる成熟度レベルが定義されています。初めての貢献者は、成熟度レベル1: 初期（構造化されていない経験報告や、欠けている部分を持つパターン）および2: 構造化（パターン形式に従い、基本的な文章表現の規則に従ったベストプラクティス）を目指すべきです。 パターンのアドボケートになる: さらに多くの人々が自分たちの視点と経験を寄せることで、パターンはより良くなり、より多くのトピックがカバーされます。同僚が斬新なAIネイティブ開発のベストプラクティスについて話してくれましたか？ぜひ彼/彼女を招待し、このリポジトリに貢献してもらいましょう！ 貢献のライセンス # このリポジトリのコンテンツはCC-BY-SA-4.0でライセンスされています。このリポジトリへの貢献により、私たち（そして誰もが）あなたの貢献をそのライセンスに従って使用する権利を付与します。\n貢献の謝辞 # パターンの著者として自分自身をリストする場合、そのパターンを参照する際にあなたに言及する許可を得たものと見なします。\n行動規範 # まだ完全に正式化された行動規範はありませんが、すべての貢献者が互いに尊重し合い、このコミュニティをハラスメントや差別のない場に保つことを助けるよう期待しています。\n"},{"id":1,"href":"/ja/menu/","title":"Index","section":"","content":" About\nようこそ プロジェクトに貢献するには General\nコード補完 コメントからコードを生成 コードからコメントの自動生成 GitHub CopilotとのクイックQ\u0026amp;A 正規表現 プログラミング言語間の翻訳 タイプヒンティング 構造化データからのオブジェクト生成 コードからドキュメントへ Client Side Tips\nCopilot スニペットハンドリング GitHub Copilot ショートカット 定義に移動 便利なファイルのピン留め Design Patterns\nAI が理解可能な命名規則 一貫性のあるコーディングスタイル ハイレベルアーキテクチャを先に 小さなコードチャンクで作業する コンテキストレス・アーキテクチャ 微細な OSS 依存関係の排除 Collaboration\nAIフレンドリーなドキュメンテーション プロンプトとコード生成プロセスのコーチング Testing\nユニットテストの作成 テストコード生成の方法を指定する 失敗ケースを最初に書く 自然言語でテストケースを最初に記述する 必要な部分だけをテストする Refactoring\nリファクタリング前にテストコードを書く 計算ロジックを独立させる オープン・クエスチョンで尋ねる Archived Version\nEnglish 🇬🇧 German 🇩🇪 Spanish 🇪🇸 French 🇫🇷 Italy 🇮🇹 Japanese 🇯🇵 Portuguese 🇵🇹 Chinese 🇨🇳 GitHub\n"},{"id":2,"href":"/ja/design-pattern/ai-readable-naming-convention/","title":"AI が理解可能な命名規則","section":"Design-patterns","content":" AIが読み取り可能な命名規則 # Description # AIが理解可能な命名規則のパターンは、GitHub Copilotのような AI ツールがもっと読みやすくするためにコード内の変数と関数の命名方法に焦点を当てます。一般的でありふれたプログラミング名や、x や y のような適当な命名を避け、具体的で説明的な名前を採用することで、人間の開発者と GitHub Copilot を動かすAIモデルの両方が容易に理解できるコードを作ります。\n例えば、図書館システムを作るエンジニアは、システムの変数名や関数名に「辞書(=dictionary)」「ライブラリ(=library)」「本棚(=stack)」といった一般的な言葉を使うかもしれません。しかし、\u0026ldquo;dictionary\u0026quot;という名前を含む変数の本当の型が配列だったらどうでしょう。これはほんの一例ですが、GitHub Copilotはこうしたことが積み重なると間違った答えを提案することがあります。 さらに文脈を示す必要がある場合は、言語のタイプヒンティングを用いるか、コメントとして文脈を追加するのがよいでしょう。\nこのパターンに従うことで、GitHub Copilotの効果を高め、より正確なサジェストと開発者の速度向上につながります。\nExample # ここでは、異なる命名規則がコードの明快さと正確さにどのような影響を与えるかを示す3つの例を紹介します:\nAmbiguous Naming:\n# This may confuse whether \u0026#34;dictionary\u0026#34; refers to a book or a data type dictionary = Better Naming with Comments:\n# sample list of dictionaries in the library, like \u0026#34;Oxford\u0026#34; and \u0026#34;Cambridge\u0026#34; library_dictionaries = [\u0026#34;Merriam-Webster\u0026#34;, \u0026#34;Oxford\u0026#34;, \u0026#34;Cambridge\u0026#34;] Specific Naming with Type Hinting:\nfrom typing import List # A clear and specific variable name with type hinting list_of_dictionaries_in_library: List[str] = [\u0026#34;Merriam-Webster\u0026#34;, \u0026#34;Oxford\u0026#34;, \u0026#34;Cambridge\u0026#34;] Exercise # エクササイズ 1: 現在のコードベースを見直し、非記述的な方法で名前が付けられている可能性のある変数や関数を特定します。それらをAIが読み取り可能な命名規則に従ってリネームしてみてください。 エクササイズ 2: 新しい命名パターンで GitHub Copilot を使用して実験し、変更前後の提案と精度を比較してみてください。 エクササイズ 3: この命名規則を念頭に置いて新しいコードを書いてみて、Copilotがコードにどのように反応するかを観察してみてください。 エクササイズ 4: チーム向けに AI の可読性に焦点を当てた命名規則ガイドラインを作成し、チームのコーディング標準に組み込んでみてください。 エクササイズ 5: チームにこれらの命名規則の使用を奨励し、全体のコードの可読性と GitHub Copilot の効果に対する影響を時間をかけて観察してみてください。 Further Learningのチェックリスト # 人間の開発者とAIモデルの両方にコードをもっと読みやすくするにはどうすればいいですか? この命名パターンが適用できない、または逆効果になる特定のケースはありますか? "},{"id":3,"href":"/ja/collaboration/ai-friendly-documentation/","title":"AIフレンドリーなドキュメンテーション","section":"Collaborations","content":" AIフレンドリーなドキュメンテーション # Description # AI を用いたコーディング支援ツールである GitHub Copilotの時代には、テキストベースで AI が容易にアクセスできるドキュメントが重要です。AI の時代では、Infrastructure as Code、データベーステーブル仕様、テスト要件などのファイルは、即座に実際のコードに変換できる可能性を持っています。複雑なエクセル、パワーポイントファイル、PDF、画像形式ではなく、テキストベースのドキュメントによって AI があなたのコーディングを協力に支援することができるようにになります。\n以下のファイルがテキストベースであるか確認します:\nインフラストラクチャ定義 データベーステーブル定義 テスト仕様 Example # 例えば、以下のようなマークダウンで書かれたテーブルがある場合、GitHub Copilot はマイグレーションファイルのベースを提供します。\n# | No. | Item Name | Type | Length | Decimal | Required | Primary Key | Remarks | # | --- | -------------------- | --------------------------- | ------ | ------- | -------- | ----------- | ---------------------- | # | 1 | pass_document_id | integer | | | Y | Y | Document ID | # | 2 | checkout_id | integer | | | Y | Y | Unique Serial Number | # | ... | ... | ... | ... | ... | ... | ... | ... | # | 15 | update_datetime | timestamp-without-time-zone | | | | | Update Timestamp | # Create migration file of cooperation_pass public class CreateGovernmentPass \u0026lt; ActiveRecord::Migration[7.0] def change # \u0026lt;Copilot Suggestion Here\u0026gt; Exercise # エクササイズ 1: 既存のドキュメントをチェックし、テキストベースでないファイルをリストします。 エクササイズ 2: テキストベースでないファイルのうちの1つをマークダウンまたはプレーンテキストファイルに変換し、以前の形式とのアクセシビリティを比較します。 エクササイズ 3: リポジトリをスキャンし、テキストベースでないドキュメントがコミットされた場合に警告するスクリプトを書きます。 Checklist for Further Learning # チームメンバーがテキストベースのドキュメントの標準を守っていることをどのように確保できますか? 他にどんなチーム/プロジェクトのドキュメントがテキストで書かれていたら、開発の速度を上げることができますか? テキストベースのドキュメントの採用が AI ツール のGitHub Copilot を使った開発をどのように改善できますか? "},{"id":4,"href":"/ja/client-tips/copilot-snippet-handling/","title":"Copilot スニペットハンドリング","section":"Client-tips","content":" Copilot スニペットハンドリング # {% hint style=\u0026ldquo;info\u0026rdquo; %} この情報は2023年8月現在のものですが、GitHub Copilotとその背後にあるLLMの進化に伴い、状況が変わる可能性があります。常にGitHubから最新の情報を得るようにしてください。 {% endhint %}\nDescription # そして、GitHub Copilot は OpenAI の 大規模言語モデルを利用してコードを生成するため、トークンの数に制限があります。2023 年現在、GitHub Copilot はエディタで開いているコード全てを見ることができず、また AI もすべてのコードをトークンとして受け取るわけではありません。これは、ユーザーが GitHub Copilot に提供するコンテキストを慎重に制限する必要があることを意味しています。特筆すべきは、GitHub Copilot は外部リポジトリや GitHub.com / GitHub Enterprise Cloud に置かれたソースコードにはアクセスしていないということです。\nGitHub Copilot が提案に使用するファイルは、主に現在開いているファイルとそれに隣接するタブファイル(基本的には同じファイル拡張子)です。 正確な提案をするためには、関連するファイルだけを開いておくことが不可欠です。 以下は、2023年8月時点のチェックリストです。 GitHub Copilot がスニペットとして含めるファイルの種類は将来変更される可能性がありますが、「不要なファイルを閉じる」などの実践は、GitHub Copilot を使用していない場合であっても、コーディングにプラスの影響を与える可能性があります。\n参照する必要があるファイルを開く 不要なファイルを閉じる 参照したい 他の拡張子のファイル (例: .md, .csv) がある場合は、コピーしてコメントアウトする Example # Pythonの関数を1つのタブで書いており、隣接するタブに似たような関数があるシナリオを考えてみましょう。GitHub Copilotはパターンを認識し、改善の提案を行うことができます。\n# タブ 1 (隣接) def add_numbers(a, b): return a + b # タブ 2 def subtract_numbers(a, b): return a - b answer = substruct_numbers(1, 2) + add_numbers( # \u0026lt;GitHub Copilot will suggest the code by reading the tab 1 \u0026gt; Exercise # エクササイズ 1: 複数のタブを開いてGitHub Copilotを試し、提案がどのようにされるかを観察してみてください。 エクササイズ 2: 特定のタブを閉じて、その動作がどのように変わるかを確認してみてください。 エクササイズ 3: 複雑なプロジェクトで Copilot へ送信されるコードの文脈をを減らして実験してみてください。これが提供される提案にどのように影響するか観察してみましょう。 Checklist for Further Learning # Copilot に必要なコンテキストを最適に与えるには、どのような戦略を採用することができますか? コメントにおける言語の選択は、多様なチーム内の協力にどのように影響しますか? ノート # GitHub Copilotは常に進化と改善を続けており、アルゴリズムも更新される可能性があります。この情報は2023年8月時点の正確な情報です。 今後このトークン制約は緩和される可能性があります。\n"},{"id":5,"href":"/ja/client-tips/github-copilot-shortcuts/","title":"GitHub Copilot ショートカット","section":"Client-tips","content":" GitHub Copilot ショートカット # Description # GitHub Copilot は、開発者にコーディングプロセスを加速させるためのキーボードショートカットを提供します。これらのショートカットは、GitHub Copilot のAIによる提案とのナビゲーションやインタラクションを直感的かつ効率的に行うのに役立ちます。このパターンでは、GitHub Copilot を使用した迅速なコード開発に不可欠なキーボードショートカットを探求します。\nExample # 例えば、GitHub Copilot からの提案を受け入れるには、TAB を押すだけで良いです。以下はいくつかの重要なショートカットのリストです:\n提案を受け入れる: TAB 提案を拒否する: Esc 複数の提案を表示する: Ctrl + Enter 単語レベルで受け入れる: Ctrl + → 次の提案を見る: Alt + ] 前の提案を見る: Alt + [ インライン提案をトリガーする: Alt + / Labs 機能リストを表示する: Ctrl + Shift + Alt + e サイドバーを切り替える: Ctrl + Shift + a Exercise # エクササイズ 1: 現在のプロジェクトで TAB を使って GitHub Copilot の提案を受け入れてみてください。 エクササイズ 2: Esc を押して提案を拒否してみてください。何が起きますか? エクササイズ 3: Ctrl + Enter を使用して組み合わせた提案を確認します。それらを探索し、有用なものを特定してみてください。 エクササイズ 4: Alt + ] と Alt + [ を使用して提案をナビゲートしてみてください。コード選択プロセスにどう影響しますか? エクササイズ 5: 上記の他のショートカットを試し、それぞれの経験を説明してみてください。 Checklist for Further Learning # GitHub Copilot の提案を受け入れたり拒否したりするショートカットを身につけましたか? 複数の提案をナビゲートするショートカットを使うのに慣れましたか? GitHub Copilot でのコーディング経験を向上させるために、VSCode 内で他にどのようなショートカットがありますか? 自分の個人的なコーディングワークフローに合うようにショートカットをカスタマイズする方法はありますか? これらのショートカットの使用は、Visual Studio Code と GitHub Copilot でのみ、または他のコーディング環境でも私に役立つ可能性がありますか? "},{"id":6,"href":"/ja/general/quick-qna/","title":"GitHub CopilotとのクイックQ\u0026A","section":"Generals","content":" GitHub CopilotとのクイックQ\u0026amp;A # Description # コーディングの際には、素早い対話と明確化が効率的な開発の鍵となることがよくあります。GitHubは \u0026ldquo;GitHub Copilot Chat\u0026rdquo; プロダクトを持っていますが、\u0026ldquo;クイックQ\u0026amp;A\u0026rdquo; テクニックは軽量な代替手段として機能します。これにより、開発者はコードエディタの中でキーボードのポジションを離れることなく GitHub Copilot と素早くやり取りし、簡潔な回答と洞察を得ることができます。これは独自の機能ではなく、GitHub Copilot との素早い対話のためにコメントを活用する方法で、敏捷性のための便利なツールとして役立ちます。\nExample # クイックチャット技法を使用すると、コード内で直接質問をし、Copilotから簡潔な回答を得ることができます。\n# me: このループを最適化する最良の方法は何ですか? # copilot: その後、GitHub Copilot が質問に回答します\n# me: このループを最適化する最良の方法は何ですか? # copilot: ベクトル化されたアプローチを使用するか、中間結果をキャッシュすることを検討してください。 \u0026ldquo;q:\u0026rdquo; と \u0026ldquo;a:\u0026rdquo; だけでも構いません\n// q: ミリ秒単位で現在の時刻を取得するにはどうすればよいですか? // a: 詳細な対話のために、役割を定義することができます:\n# Roles: copilot # Python のエキスパートで 15 年以上の経験があります # Role: me # 中堅エンジニア # # me: このループを最適化する最良の方法は何ですか? # copilot: ベクトル化されたアプローチを使用するか、中間結果をキャッシュすることを検討してください。 Exercise # エクササイズ 1: \u0026ldquo;GitHub Copilot Chat\u0026rdquo; とエディタ内でのクイックチャットを使用して比較し、違いを考えてください。 エクササイズ 2: クイックチャットを使用して、3つの異なるコーディングの質問に対するワンライナーの回答を得てください。 エクササイズ 3: クイックチャット内で役割を定義し、文脈情報が Copilot の回答にどのように影響するかを観察してください。 Checklist for Further Learning # クイックチャットは GitHub Copilot Chat プロダクトとどう異なり、どちらが他方より優れている場合があるのですか? クイックチャットテクニックは、開発プロセスのさまざまな段階にどのように統合することができるのですか? クイックチャットの使用における潜在的な欠点や制限は何であり、それらはどのように軽減される可能性があるのですか? "},{"id":7,"href":"/ja/refactoring/asking-with-open-ended-questions/","title":"オープン・クエスチョンで尋ねる","section":"Refactorings","content":" オープン・クエスチョンで尋ねる # Description # リファクタリングは、しばしば複雑なプロセスであります。必ずしも何が正しく、何が間違っているかについてではなく、基本概念と潜在的な改善を理解することが重要です。GitHub Copilotでオープン・クエスチョンを利用することで、開発者は GitHub Copilot の助けを借りてより熟慮した方法でコードの改善に取り組むことができます。\nExample # GitHub Copilotでのクエリに開かれた質問を導入すると、洞察に満ちた提案が得られることがあります。例えば:\n// Q: この関数の復元性をどのように改善できますか? // A: \u0026lt;GITHUB COPILOT SUGGESTION\u0026gt; function backupData(data) { // 実装はこちら } // Q: この文脈でエラーを処理する最良の方法は何ですか? // A: \u0026lt;GITHUB COPILOT SUGGESTION\u0026gt; try { // 何かの操作 } catch (error) { // エラー処理 } Exercise # エクササイズ 1: ファイルハンドリングに関連する関数を記述し、それをより信頼性があり効率的にする方法について Copilot に尋ねてみてください。 エクササイズ 2: 例外処理を含むコードスニペットを作成し、エラー報告の改善について Copilot に提案を求めてください。 エクササイズ 3: シンプルな UI コンポーネントを設計し、それに対するアクセスや操作をよりエレガントにする方法について Copilot に尋ねてみてください。 Checklist for Further Learning # 既存のコードのどの部分がリファクタリングから利益を得ることができますか? オープンクエスチョンが開発プロセスでどのように機能しますか? "},{"id":8,"href":"/ja/general/code-to-comment/","title":"コードからコメントの自動生成","section":"Generals","content":" コードからコメントの自動生成 # Description # GitHub Copilot はコードからコメントを生成できます。既存のコードが十分なコメントを欠いている場合や、他の開発者がコードを理解するのを助けるために、GitHub Copilot を使ってコメント形式で自動的に説明を生成しましょう。\nExample # 以下のサンプルは、与えられた数より小さい素数をリストするエラトステネスのふるいのアルゴリズムを示しています。このコードにはコメントが含まれていませんが、GitHub Copilotはコードの機能を説明するコメントを作成しています。\nコメントなしのコードはこちらです:\ndef eratosthenes_sieve(n): primes = [] sieve = [True] * (n + 1) for p in range(2, n + 1): if sieve[p]: primes.append(p) for i in range(p * p, n + 1, p): sieve[i] = False return primes GitHub Copilotがそれを説明するコメントを追加する方法は次のとおりです:\n# Write the description of the method here \u0026lt;- [Actual Prompt] # Input: n - the number of primes to return # Output: a list of the first n primes # Example: eratosthenes_sieve(5) -\u0026gt; [2, 3, 5, 7, 11] # Note: this is a very inefficient way to find primes, but it is easy to understand def eratosthenes_sieve(n): primes = [] sieve = [True] * (n + 1) for p in range(2, n + 1): if sieve[p]: primes.append(p) for i in range(p * p, n + 1, p): sieve[i] = False return primes Exercise # エクササイズ: 次の関数の先頭にあるコードに適切なコメントを生成してください: def eratosthenes_sieve(n): primes = [] sieve = [True] * (n + 1) for p in range(2, n + 1): if sieve[p]: primes.append(p) for i in range(p * p, n + 1, p): sieve[i] = False return primes Checklist for Further Learning # 生成されたコメントは、コードの機能とアルゴリズムを適切に説明していますか? コメントは他の開発者がコードを理解するのに役立っていますか? 生成されたコメントが間違っている場合、その理由は何だと思いますか? "},{"id":9,"href":"/ja/general/code-to-document/","title":"コードからドキュメントへ","section":"Generals","content":" コードからドキュメントへ # Description # チャットベースのAIツールを使用することで、説明を自動生成するだけでなくドキュメントなどの長い文章を生成することができるようになります。例えば、GitHub Copilot Chat を活用することで、コード全体の概要説明や API ドキュメントを生成したり、またそれをコードの中に埋め込んだ状態でコードごと出力させる事ができるようになります。\nExampleコード # 以下は、Ruby on Railsのコントローラー向けのコードスニペットです。\nclass RecipesController \u0026lt; ApplicationController before_action :set_recipe, only: [:show, :edit, :update, :destroy] # GET /recipes # GET /recipes.json def index @recipes = Recipe.all end # GET /recipes/1 # GET /recipes/1.json def show end # GET /recipes/new def new @recipe = Recipe.new end # GET /recipes/1/edit def edit end # POST /recipes # POST /recipes.json def create @recipe = Recipe.new(recipe_params) respond_to do |format| if @recipe.save format.html { redirect_to @recipe, notice: \u0026#39;Recipe was successfully created.\u0026#39; } format.json { render :show, status: :created, location: @recipe } else format.html { render :new } format.json { render json: @recipe.errors, status: :unprocessable_entity } end end end # PATCH/PUT /recipes/1 # PATCH/PUT /recipes/1.json def update respond_to do |format| if @recipe.update(recipe_params) format.html { redirect_to @recipe, notice: \u0026#39;Recipe was successfully updated.\u0026#39; } format.json { render :show, status: :ok, location: @recipe } else format.html { render :edit } format.json { render json: @recipe.errors, status: :unprocessable_entity } end end end # DELETE /recipes/1 # DELETE /recipes/1.json def destroy @recipe.destroy respond_to do |format| format.html { redirect_to recipes_url, notice: \u0026#39;Recipe was successfully destroyed.\u0026#39; } format.json { head :no_content } end end private # Use callbacks to share common setup or constraints between actions. def set_recipe @recipe = Recipe.find(params[:id]) end # Never trust parameters from the scary internet, only allow the white list through. def recipe_params params.require(:recipe).permit(:title, :instructions) end end Example結果 # 以下は、上記のRubyコードから生成された仕様書の一例です。マークダウン形式で表示されています。\n## RecipesController RecipesControllerは、レシピの作成、表示、編集、削除などの操作を提供します。 ### アクション #### `index` - 説明: レシピのリストを取得します。 - メソッド: GET - パス: `/recipes` - レスポンス: レシピのリスト #### `show` - 説明: 特定のレシピに関する詳細情報を取得します。 - メソッド: GET - パス: `/recipes/:id` - パラメータ: `id` - レシピのID - レスポンス: レシピの詳細情報 #### `new` - 説明: 新しいレシピの作成画面を表示します。 - メソッド: GET - パス: `/recipes/new` #### `edit` - 説明: 特定のレシピの編集画面を表示します。 - メソッド: GET - パス: `/recipes/:id/edit` - パラメータ: `id` - レシピのID #### `create` - 説明: 新しいレシピを作成します。 - メソッド: POST - パス: `/recipes` - パラメータ: `recipe` - レシピの情報 - レスポンス: 作成されたレシピの詳細情報 #### `update` - 説明: 特定のレシピを更新します。 - メソッド: PATCH/PUT - パス: `/recipes/:id` - パラメータ: `id` - レシピのID, `recipe` - 更新情報 - レスポンス: 更新されたレシピの詳細情報 #### `destroy` - 説明: 特定のレシピを削除します。 - メソッド: DELETE - パス: `/recipes/:id` - パラメータ: `id` - レシピのID - レスポンス: 削除されたレシピの詳細情報 Exercise # エクササイズ 1: 提供されたRubyコードを活用し、ユーザーマニュアル、APIリファレンス、コードコメントなど、異なる種類のドキュメントを生成してみてください。違いと類似点を比較してみてください。 エクササイズ 2: Rubyコードをより複雑な機能を持つものに変更し、GitHub Copilot Chatを使用して対応するドキュメントを生成してみてください。生成されたドキュメントの正確さと完全性を分析してみてください。 エクササイズ 3: GitHub Copilot ChatのようなAIツールを使用してドキュメントを生成する際に考慮すべき重要なガイドラインを作成してみてください。これらのガイドラインには、明確さ、正確さ、一貫性、保守性に関する考慮事項が含まれるべきです。 Checklist for Further Learning # 生成されたドキュメントは、各アクションやコードの機能を適切に説明していますか? ドキュメントはAPIの仕様を明確に表していますか? コードからドキュメントを生成する際に考慮すべきポイントは何でしょうか? "},{"id":10,"href":"/ja/general/code-completion/","title":"コード補完","section":"Generals","content":" コード補完 # Description # GitHub Copilot の最もシンプルな使用法のひとつはコード補完です。コード補完は、開発者がタイピングする際に潜在的なコードスニペットを提供することで開発者の生産性を向上させます。例えば、JavaScript の関数を定義することを想像してみてください。以下のコードを入力する際に、GitHub Copilot は関数内で使用できる潜在的なコードを提案します。\nExample # 入力コード # function calculateSum(a, b) { // Enter your code here } Copilot による提案結果 # function calculateSum(a, b) { // Enter your code here const sum = a + b; return sum; } Exercise # エクササイズ 1: GitHub Copilot の提案を活用して calculateSum(a, b) 関数を完成させます。異なるプロンプトや部分的なコード入力が Copilot による提案にどう影響するかを探求します。 Checklist for Further Learning # あなたのコードの出力は提供されたサンプルコードに似ていましたか? 出力されたコードは堅牢ですか? エラー処理は考慮されていますか? されていない場合どうすればよいですか? より正確なコードを書くためにどのようなプロンプトや文脈を追加できますか? "},{"id":11,"href":"/ja/general/comment-to-code/","title":"コメントからコードを生成","section":"Generals","content":" コメントからコードを生成 # Description # コードからコードを生成するコード補完のテクニックと同様に、最もベーシックな GitHub Copilot のテクニックです。GitHub Copilot は、開発者が提供した特定のテキストに基づいて新しいコードを生成することができます。コメントの形式で条件を定義することで、GitHub Copilot は要件に応じたコードを作成することができます。\nExample # 以下は、コメントを通じて GitHub Copilot に関数を作成するよう指示する方法です:\n// Function name: calculateAverage // Function arguments: numbers (array) // Return type of the function: number これらのコメントに基づいて、Copilot は次のようなコードを提案します:\nfunction calculateAverage(numbers: number[]): number { // calculate the average of the array const sum = numbers.reduce((a, b) =\u0026gt; a + b); return sum / numbers.length; } Exercise # エクササイズ 1: 配列内の最大数値を計算する関数を作成するよう Copilot に指示するコメントを書いてください。以下の仕様を使用してください: // Function name: calculateMax // Function arguments: numbers (array) // Return type of the function: number エクササイズ 2: さまざまな数値セットで生成された関数をテストし、正しい最大値を返すかどうかを確認してください。 Checklist for Further Learning # 生成されたコードは、指定された条件に基づいていますか? コードの機能は正しく実装されていますか? より複雑な条件定義のためにコメントを書く適切な方法は何ですか? より多くのコンテキストを与えるために、キーボードだけでなく、OS の音声入力も使ってみましょう。 "},{"id":12,"href":"/ja/design-pattern/context-less-architecture/","title":"コンテキストレス・アーキテクチャ","section":"Design-patterns","content":" コンテキストレス・アーキテクチャ # {% hint style=\u0026ldquo;info\u0026rdquo; %} 疎結合アーキテクチャ自体も多くの場合推奨されており、このパターンはその考え方に合致しています。しかし、AIを活用した開発の文脈をより広範なアーキテクチャの議論と結びつけ、それを正当化するためには、より多くの議論が必要です。ぜひディスカッションを始めましょう! {% endhint %}\nDescription # コンテキストレス・アーキテクチャは、システム内のより小さく、明確に定義されたコンテキストにコーディングを限定するデザインパターンです。複雑なプログラムを疎結合で独立したコンポーネントに分割することで、このアーキテクチャは保守性、拡張性、柔軟性を向上させます。\nGitHub Copilot のような AIツールと連携する際、その性質と制限を理解することが不可欠です。現在の GitHub Copilot は AGI (Artificial General Intelligence) ではないため、限定された正確なコンテキスト内で最も効果的に動作します。特定のニーズに焦点を当てることで、開発者は GitHub Copilot の正確性と効率を最大化することができます。\nキーとなるのは、各コンポーネントが特定の目的に役立つ疎結合なシステムを作成することです。このアプローチは GitHub Copilot の制限と合致しており、開発者がツールをより効果的に使用して、モジュラーで堅牢なソフトウェアを構築することができます。 一方で、ツールにあわせてシステムのデザインを決めることは本質的なことではありません。 このパターンは現実のプロジェクトやプロダクトにおいて、疎結合であることが意味を成す場合に、AI の開発における活用を追加で考えることで、より効果的に開発速度が上がることを目的としています。\nExample # Before # ここでは、ユーザー管理と認証が混ざり合っており、コンテキストが不明確で絡み合っています。\nclass UserManager: def create_user(self, username, password): # Code to create user pass def login(self, username, password): # Code to handle login pass def update_user_profile(self, user_id, profile_data): # Code to update user profile pass After # コンテキストレス アーキテクチャを適用することで、ユーザー管理と認証が明確なコンテキストに分離されます。\nclass Authentication: def login(self, username, password): # Code to handle login pass class UserProfile: def update_profile(self, user_id, profile_data): # Code to update user profile pass これらの例は、コンテキストレス・アーキテクチャ パターンを適用することで、混在して混乱しがちなコンテキストを、すっきりと明確に定義されたコンテキストに変換することを示しています。 このアプローチは、GitHub Copilot で作業する場合に特に有益で、大規模で混在したコンテキストを処理する上でのGitHub Copilot の限界を考慮する必要があります。\nこのアーキテクチャにより、開発者はもちろん、GitHub Copilotも個々のコンポーネントに集中することができ、AIがコードを理解し、正確にコード開発にさらに貢献できるようになります。\nExercise # エクササイズ 1: GitHub Copilot を使用して小さなコンテキストでコンポーネントを実装し、コンテキストの制限が理解を高める方法を反映させます。 エクササイズ 2: コンテキストが制限されたコンポーネント間の通信システムを GitHub Copilot で作成し、限定されたコンテキスト内でのパフォーマンスを評価します。 エクササイズ 3: 全体的なアーキテクチャを見直し、GitHub Copilot との連携の相乗効果と課題を考慮し、潜在的な改良を計画します。 Checklist for Further Learning # GitHub Copilot と共にコンテキストレス アーキテクチャパターンを一貫して適用し、最適な結果を達成するためにはどうすればよいですか? GitHub Copilot の精度を最大化するために、正しいコンテキストサイズを提供するための戦略は何ですか? さまざまなプロジェクトでこのパターンを実装する際の課題は何でしょうか。 さまざまな開発シナリオにおいて、GitHub Copilot を使ったコンテキストレスアーキテクチャの使い方を進化させ、洗練させていくにはどうすればよいでしょうか。 "},{"id":13,"href":"/ja/general/type-hinting/","title":"タイプヒンティング","section":"Generals","content":" タイプヒンティング # Description # 動的型付けプログラミング言語の世界では、開発者は特に複雑なシステムでコードを理解する際に課題に直面することがよくあります。タイプヒンティングは、期待されるデータ型を明示的に宣言することで、明確さの層を追加します。 GitHub Copilot を使う際にもタイプヒンティングを使うことにより、コード提案の精度を高め、開発者と GitHub Copilot がより効率的にコードを書くのを支援します。\n深くネストされた関数でプロジェクトに取り組んでいると想像してみてください。変数の型を追跡するのが複雑になります。タイプヒンティングの統合は、同僚の開発者にとってコードをより読みやすくすることにも繋がります。\nExample # Python でタイプヒンティングを使用して関数を定義する方法は以下の通りです。\ndef add_numbers(a: int, b: int) -\u0026gt; int: return a + b GitHub Copilot はこれらのタイプヒンティングを認識し、それに応じてコード提案を生成します。\nExercise # エクササイズ 1: タイプヒンティングを使用して、2つの文字列パラメータを取り、それらの連結を返す関数を書いてください。 エクササイズ 2: プロジェクト内の既存のコード片をタイプヒンティングを含むように変換し、GitHub Copilot の提案の違いを観察してください。 エクササイズ 3: 複数のメソッドを持つ複雑なクラスを作成し、すべてのパラメータと戻り値のタイプヒンティングを使用してください。 Checklist for Further Learning # コードベース全体でタイプヒンティングを一貫して使用していますか? タイプヒンティングの過剰な使用の潜在的な欠点を考慮しましたか、そしてコード内での適切なバランスをどのように見つけるかですか? "},{"id":14,"href":"/ja/testing/specify-test-valiation/","title":"テストコード生成の方法を指定する","section":"Testings","content":" テストコード生成の方法を指定する # Description # テストに関する指示を具体的に示すことは、必要なシナリオをすべてカバーする良い方法です。\u0026ldquo;ユニットテストを追加する\u0026quot;といった曖昧な指示ではなく、テストフレームワークや生成するケースの数などの具体的な詳細を提供することができます。GitHub Copilotのようなツールを活用する際には、「JunitとMockitoを使用してユニットテストを追加し、少なくとも10種類の有効な/無効な入力の組み合わせをテストする」といった指定を行うことで、より正確で包括的な結果を得ることができます。\nExample # Junit と Mockito を使用してテストコードを生成する場合、次のプロンプトを GitHub Copilot に提供できます:\n// JunitとMockitoを使用してユニットテストを追加する // 少なくとも10種類の有効な/無効な入力の組み合わせをテストする @Test public void validateInput() { // ここにコードを記述 } Exercise # エクササイズ1: Junit を使用して、異なる3つの有効な入力で単純なメソッドをテストするユニットテストを書いてみましょう。 エクササイズ2: ユニットテストを拡張して、3つの異なる無効な入力を含め、例外が適切に処理されることを確認します。 Checklist for Further Learning # コード内のすべての重要なパスをテストする方法はどのように確保できるでしょうか? テストが必ず失敗するようにテストコードを書くことはできますか? コードベースが進化するにつれてテストを維持するためにどのような戦略をとることができますか? "},{"id":15,"href":"/ja/design-pattern/high-level-architecture-first/","title":"ハイレベルアーキテクチャを先に","section":"Design-patterns","content":" ハイレベルアーキテクチャを先に # Description # 複雑なシステムを開発するとき、いきなり細部のコードに飛び込み、プログラムの全体的なアーキテクチャを見失うことはよくあることです。このような事が繰り返されると、同時に GitHub Copilot も全体的なアーキテクチャを見失うことに繋がります。これは誤解やエラーの原因となってしまいます。開発において、プログラムのハイレベルなアーキテクチャを先に設計し、コードの各部分の機能と目的についてコメントしていくことにより、GitHub Copilot も文脈をよりよく理解し、より的確な提案をすることができます。\nExample # ウェブアプリケーションでのAPIエンドポイントファイルを考えてみましょう。初期に設計を自然言語で提案することは、各エンドポイントの機能を GitHub Copilot に理解させるのに役立ちます。\n# GET /items # - アイテムのリストを取得します。 # - 応答でアイテムのコレクションを返します。 # # POST /items # - 新しいアイテムを作成し、コレクションに追加します。 # - リクエストでアイテムのパラメーターが必要です。 # - 成功時に成功メッセージとともにカートページにリダイレクトします。 # - 失敗した場合、新しいアイテムのフォームを表示します。 # # GET /items/:id # - 特定のIDを持つアイテムを取得します。 # - URLパラメーターとしてアイテムのIDが必要です。 # - 応答で要求されたアイテムの詳細を返します。 # ... Exercise # エクササイズ: バックエンドの簡単な API について、各エンドポイントに対するコメントを含め、ログインと登録システムのハイレベルアーキテ クチャのアウトラインを作成します。 Checklist for Further Learning # コードの詳細を書く前に明確なロードマップを確立しましたか? GitHub Copilot は、ハイレベルのコメントを読むだけで、ファイルの目的を理解できますか? このパターンをコードベース全体で一貫して適用していますか? "},{"id":16,"href":"/ja/general/language-translation/","title":"プログラミング言語間の翻訳","section":"Generals","content":" 言語翻訳 # Description # 時に、開発者が Python から JavaScript や HTML から Markdown など、一つの言語から別の言語にコードを翻訳する必要があるかもしれません。チームがマルチプラットフォームプロジェクトに取り組んでいて、PythonのアルゴリズムをWeb 統合のために JavaScript に素早く変換する必要がある場合を想像してみてください。GitHub Copilot のプログラミング言語翻訳能力は、手動での翻訳にかかる時間を節約し、シームレスなクロス言語開発を可能にします。\nExample # Python 関数を JavaScript に翻訳する例は以下の通りです:\nPython コード:\ndef add(a, b): return a + b GitHub Copilotを使用すると、これを簡単にJavaScriptに翻訳できます:\nfunction add(a, b) { return a + b; } Exercise # エクササイズ 1: GitHub Copilotを使用して、シンプルな HTML 構造を Markdown に翻訳してください。 エクササイズ 2: 与えられた Python 関数を、それに相当する Java に変換してください。 エクササイズ 3: C#の関数を書いて、それを GitHub Copilot を使用して Ruby に翻訳してください。 Checklist for Further Learning # GitHub Copilotは、特定の言語間でより正確な翻訳を提供するために、どのようにさらに最適化できますか? GitHub Copilotで一つの言語から別の言語にコードを翻訳する際の制限、もしあれば何ですか? クロス言語プロジェクトをより効率的にするために、共同環境でGitHub Copilotをどのように活用できますか? GitHub Copilot と GitHub Copilot Chat を使った際の違いはどのようなものですか? "},{"id":17,"href":"/ja/collaboration/coaching-on-prompts/","title":"プロンプトとコード生成プロセスのコーチング","section":"Collaborations","content":" プロンプトとコード生成プロセスのコーチング # {% hint style=\u0026ldquo;info\u0026rdquo; %} これは合理的に聞こえますが、体系的で確立されたパターンではありません。 {% endhint %}\nDescription # GitHub Copilot のような AIツールを使用すると、出力が整ったものに見えることがあります。レビュー時に完璧に見えるコードも、生成プロセスで非効率であったり、重要な部分が欠けていることがあるかもしれません。生成プロセスへのコーチングは、開発者が潜在的な問題を認識し、効率的かつ正確なコードを作成できるようにするために不可欠です。\n現代のソフトウェア開発において、コーチングはレビュー以上のものです。ガイドし、インスピレーションを与え、改善する機会となります。 このパターンは、GitHub Copilot のような AIツールでのコード生成に使用されるプロンプトの品質に対する仲間へのコーチングを強調しています。コーチングではプロンプトだけでなく、生成プロセスの理解も高めることを目指します。\nExample # 特定のタスクのコードを生成するプロンプトを作成したチームメートのシナリオを想像してみてください。あなたの役割は、プロンプトの明確さを向上させ、基礎となる生成プロセスを理解するためのコーチングを提供することです。\n元のプロンプト:\n\u0026#34;Create a function to find prime numbers within a range.\u0026#34; コーチング後のプロンプト:\n\u0026#34;Develop a Python function that takes two integers as input and returns a list of prime numbers within that range. Ensure the function efficiently handles different ranges, including edge cases.\u0026#34; Exercise # エクササイズ 1: チームメンバーのプロンプトに対してコーチングをしてください。改善できる分野を特定し、生成プロセスに対する洞察を提供し、変更がなぜ有益であるかを説明してください。 エクササイズ 2: GitHub Copilot によって以前に生成されたコードスニペットを分析し、プロンプトと基礎となる生成プロセスの両方に焦点を当てます。それがより具体的で効率的になるようにコーチングを提供してください。 エクササイズ 3: 様々なプログラミングのシナリオに対して自分自身のプロンプトを作成する練習をしてください。プロンプトの品質とコード生成プロセスの理解の両方を強調して、仲間とコーチングを行ってください。 Checklist for Further Learning # 単なるレビューと、継続的な改善のためのコーチングとの違いを認識しましたか? プロンプトの品質とコード生成の理解の両方を向上させるために、私のコーチングはどのように効果的にすることができますか? チーム内のコーチングプロセスを強化するために、どのような協力ツールや実践が有効でしょうか? AI ツールを使用する特に、一貫したコーチングは、より効率的で正確なコード生成にどのようにつながりますか? "},{"id":18,"href":"/ja/testing/creating-unit-tests/","title":"ユニットテストの作成","section":"Testings","content":" ユニットテストの作成 # Description # テストはソフトウェア開発プロセスの基本的な部分であり、コードが設計どおりであり、意図した通りに動作することを確認します。システムの個々のコンポーネントをテストするユニットテストの作成は、チャレンジングで時間のかかる作業です。GitHub Copilotを使用すると、このプロセスがより効率的になります。開発者のAliceさんがGitHub Copilotをどのように活用してアプリケーションのユニットテストを記述し、作業量を減少させ、効率を向上させるかを探ってみましょう。 このパターンは、機能テストや API テストにも適用可能です。\nExample # 徹底的にテストする必要のある JavaScript の関数に取り組んでいます。GitHub Copilotの助けを借りて、必要なユニットテストを素早く生成できます。\n以下は、テストしたいシンプルな関数です:\nfunction add(x, y) { return x + y; } そして、GitHub Copilotの支援を受けてユニットテストを作成する方法は次のとおりです:\nconst assert = require(\u0026#39;assert\u0026#39;); describe(\u0026#39;add関数\u0026#39;, () =\u0026gt; { it(\u0026#39;2つの数値を正しく加算する必要があります\u0026#39;, () =\u0026gt; { assert.equal(add(2, 3), 5); }); }); Exercise # エクササイズ1: GitHub Copilotを使用して2つの数値を掛ける関数のユニットテストを作成してください。 エクササイズ2: Copilotを活用して、nullやundefinedの値を処理するなど、さまざまなエッジケースのテストスイートを作成してください。 エクササイズ3: 現在のプロジェクトを振り返り、テストが不足しているコードの部分を特定し、Copilotを使用してユニットテストを作成してください。 Checklist for Further Learning # 自分のテストが包括的であり、すべての可能なシナリオをカバーしていることをどのように確認できますか? GitHub Copilot がシナリオを全くカバーしなかった際にどのようなプロンプトを追加しますか? 他の種類のテスト(E2Eテスト、統合テスト、機能テストなど) に対して、GitHub Copilot はどのように有益であり、それらを記述する際に GitHub Copilotはどのように支援できるか? "},{"id":19,"href":"/ja/refactoring/writing-test-code-before-refactoring/","title":"リファクタリング前にテストコードを書く","section":"Refactorings","content":" リファクタリング前にテストコードを書く # Description # ソフトウェア開発の現代世界において、GitHub Copilotのようなツールが手元にあると、リファクタリングは楽しく魅力的なタスクになるかもしれません。変更を加えることは非常に簡単ですが、適切なテストがない場合、最も有望なコードの変更でも予期せぬ結果につながることがあります。このパターンは、コードをリファクタリングする前にテストを記述して機能が一貫していることを確認する重要性を強調しています。テストを安全ネットと考えてください。問題が深刻化する前に問題を検出します。\nExample # ショッピングカートの合計価格を計算する関数があるとし、これをより明確にリファクタリングしたいと考えたとします。以下は元のコードです:\ndef total_price(items): return sum(item[\u0026#39;price\u0026#39;] * item[\u0026#39;quantity\u0026#39;] for item in items) リファクタリング前に、既存の機能が保持されていることを確認するためにテストを記述します:\ndef test_total_price(): items = [ {\u0026#39;price\u0026#39;: 5, \u0026#39;quantity\u0026#39;: 2}, {\u0026#39;price\u0026#39;: 3, \u0026#39;quantity\u0026#39;: 1} ] assert total_price(items) == 13 これでコードをリファクタリングして、可読性を向上させることができます:\ndef total_price(items): total = 0 for item in items: total += item[\u0026#39;price\u0026#39;] * item[\u0026#39;quantity\u0026#39;] return total テストはまだ合格しますので、リファクタリングによって期待される結果が変わっていないことを保証します。\nExercise # エクササイズ 1: リファクタリングが必要な関数を記述し、それに対応するテストを記述します。 エクササイズ 2: テストが合格することを確認しながら関数をリファクタリングします。 エクササイズ 3: リファクタリングした関数に誤った変更を加えてエラーが発生する状況を模倣し、テストがエラーを検出する過程を観察します。 Checklist for Further Learning # コードの重要な側面をすべてカバーするためにテストがどのように確認されますか? 選択したプログラミング言語で、テストを記述して実行するためのツールやフレームワークは何ですか? リファクタリング時にテスト駆動開発（TDD）のプラクティスをどのように適用できますか? テストを整理するためのベストプラクティスは何ですか? コードが進化するにつれてどのようにメンテナンスや更新ができますか? "},{"id":20,"href":"/ja/design-pattern/consistent-coding-style/","title":"一貫性のあるコーディングスタイル","section":"Design-patterns","content":" 一貫性のあるコーディングスタイル # Description # 一貫性のあるコーディングスタイルは、ソフトウェア開発において非常に重要です。それはコードの可読性を向上させるだけでなく、GitHub Copilot からのより良い提案にもつながります。インデント、タブ、命名規則、コメントの書き方、言語固有の省略方法など、コーディングスタイルの領域は多岐にわたります。一様なコーディングスタイルとパターンに従うことで、開発者は優れたコーディング慣行に従いやすくなります。\nExample # 以下は、明確な関数名を使用し、コードベースのパターンに従う良い例です（snake_case を使用）:\ndef calculate_area(length, width): return length * width これと一貫性のないコーディングスタイルを比較してみてください。一貫性が無いコードの場合、GitHub Copilot から以下のような存在しない関数の提案をもらうことに繋がる可能性があります。\ndef calcSomething(l, w): area = calcArea(l, w) # \u0026lt;Code goes here\u0026gt; Exercise # エクササイズ 1: 記述的で一貫性のある命名規則を使用して関数を書く練習をします。 エクササイズ 2: コードスニペットを分析し、コーディングスタイルの非一貫性を特定します。必要な調整をします。 エクササイズ 3: GitHub Copilot を使用して小さなプロジェクトを作成し、異なるコーディングスタイルへの反応を観察します。 Checklist for Further Learning # 一貫性のあるコーディングスタイルは、コードベースの可読性と保守性にどう影響しますか? チームやプロジェクト内でコーディング基準を強制するために、どのようなコミュニケーションが必要ですか? GitHub Copilot は、コーディングのベストプラクティスをどのように支援しますか? どのような行動を促進または抑制しますか? "},{"id":21,"href":"/ja/refactoring/making-the-calculation-part-independent/","title":"計算ロジックを独立させる","section":"Refactorings","content":" 計算ロジックを独立させる # Description # ソフトウェア開発の急速に進化する世界で、GitHub Copilot のようなツールに頼ることで、開発プロセスを強化できます。しかし、複雑な計算を行う際、大規模言語モデルの現行バージョンには限界があるかもしれません。これに対処するため、開発者は計算部分を別の関数に移動してコードをリファクタリングすることができます。これにより、コードの保守性、可読性が向上し、さらに AI ツールをつかったテストや開発が容易になります。金融ソフトウェアシステムを構築している開発者が、利息計算をユーザーインターフェイスロジックから分離する必要がある場合を想像してみてください。毎回 GitHub Copilot が特定のコードを書き換えるたびにロジックが正しいかを検証するのは非常に厄介な作業です。この複雑な計算を分離することで、柔軟でより耐久性のある AI と協働できるコードベースを作成します。\nExample # 計算と注文合計の処理\n計算ロジックが他の機能と混ざっていた場合は以下のようになります。\ndef handle_order(order_items): tax_rate = 0.05 total = 0 for item in order_items: total += item[\u0026#39;price\u0026#39;] total += total * tax_rate process_payment(total) ship_order(order_items) return total 一方で、計算ロジックを別の関数に移動すると、以下のようになります。\ndef calculate_total(order_items, tax_rate=0.05): subtotal = sum(item[\u0026#39;price\u0026#39;] for item in order_items) total = subtotal + (subtotal * tax_rate) return total def handle_order(order_items): total = calculate_total(order_items) process_payment(total) ship_order(order_items) return total ここで、calculate_total 関数は注文合計に関連するすべての計算を処理し、handle_order 関数は支払いの処理や注文の発送など、他の関連機能を処理します。\nExercise # エクササイズ1: プロジェクト内のコードの一部で、計算ロジックが他の機能と混ざっている部分を特定し、上記で説明したパターンを使用してリファクタリングしてください。 エクササイズ2: 計算部分と非計算部分の両方に対してテストを書き、それらが独立して意図通りに機能することを確保してください。 Checklist for Further Learning # コードベース内の計算ロジックを隔離できる他のエリアはどのように特定できますか? 計算ロジックの分離が新しいエラーや複雑さを導入しないように、どのような戦略を使用できますか? この分離は、アプリケーションのより広いアーキテクチャと設計原則とどのように一致しますか? "},{"id":22,"href":"/ja/general/object-generation-from-structured-data/","title":"構造化データからのオブジェクト生成","section":"Generals","content":" 構造化データからのオブジェクト生成 # Description # 開発者にとって、構造化データの取り扱いは日常的なタスクです。JSONなどの形式のデータをプログラミング言語内のオブジェクトに変換することで、堅牢で保守性の高いコードを作成できます。例えば、ユーザーのリストがあり、このデータをアプリケーション内のユーザーオブジェクトに変換したい場合を想像してみてください。GitHub Copilot は、この変換プロセスをサポートし、煩雑な作業を一瞬で終わる簡単な作業に変えてくれます。\nExample # 以下は、与えられたJSONデータをユーザーオブジェクトのリストに変換するPythonの例です。\nimport json json_data = \u0026#39;[{\u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Yuki Hattori\u0026#34;}, {\u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;George Hattori\u0026#34;}]\u0026#39; users = json.loads(json_data) class User: def __init__(self, id, name): self.id = id self.name = name user_objects = [User(user[\u0026#39;id\u0026#39;], user[\u0026#39;name\u0026#39;]) for user in users] for user in user_objects: print(user.id, user.name) Exercise # エクササイズ 1: 異なる JSON 構造からオブジェクトを生成してみてください。例えば、ユーザーのアドレス情報を含むJSONなどです。 エクササイズ 2: JSON 内のデータが欠落しているようなエッジケースを取り扱ってみてください。コードが適切に処理されるようにしてください。 学習のためのチェックリスト # より複雑なデータ構造に適応するためにコードをどのように変更しますか? データをオブジェクトに変換する前に、どのような方法でデータの妥当性を確認できるでしょうか? このパターンを異なるプログラミング言語やフレームワークにどのように適用できますか? "},{"id":23,"href":"/ja/testing/writing-test-cases-in-natural-language-first/","title":"自然言語でテストケースを最初に記述する","section":"Testings","content":" 自然言語でテストケースを最初に記述する # Description # GitHub Copilotのような AI を活用したコード生成を行う際、AI に明確なコンテキストを提供せずに包括的なテストカバレッジを期待するのは難しいことです。その段階でコードでテストケースを記述しようとする代わりに、まず自然言語の記述を作成します。これにより、生成されたコードがすべての必要な基準を満たすことを確認することに焦点を当て、テストカバレッジを向上させることができます。\nExample # 以下は、自然言語でテストケースを記述する方法の例です。この方法を使用することで、コードを生成する前にさまざまなシナリオやエッジケースをカバーすることができます。\nclass TestMultiply(unittest.TestCase): def test_multiply(self): # 正数、負数、ゼロ、小数、非整数の入力など、さまざまなケースのテスト Exercise # エクササイズ1: 三角形の面積を計算する関数に対して、自然言語のテストケースを記述してください。さまざまな入力シナリオとエッジケースを考慮してください。 エクササイズ2: エクササイズ1で記述した自然言語のテストケースから、GitHub Copilotを使用してコードを生成します。結果を分析します。 エクササイズ3: より複雑な関数（例: ソートアルゴリズム）に対して、自然言語を使用してテストスイートを作成します。さまざまな入力シナリオとエッジケースを考慮してください。 学習のためのチェックリスト # コードを記述する前に自然言語でテストケースを記述する利点は何ですか? 自然言語で記述されたテストケースは、開発者と非技術的な関係者との協力をどのように改善できますか? このアプローチを使用する際の潜在的な課題は何であり、それらはどのように緩和できますか? "},{"id":24,"href":"/ja/testing/writing-failure-case-first/","title":"失敗ケースを最初に書く","section":"Testings","content":" 失敗ケースを最初に書く # {% hint style=\u0026ldquo;info\u0026rdquo; %} 失敗ケースを最初に書くことは開発において重要なことではありますが、GitHub Copilotにテストケースを適切に提案させる方法について、ベストプラクティスを見つけ出す必要があります。 {% endhint %}\nDescription # 開発サイクルにおいて、テストケースの作成は重要な側面です。GitHub Copilot を使用すると、実装を読み取り、それに応じてテストケースを生成するため、さらに便利になります。一方で GitHub Copilot は成功ケースの生成に非常に効果的ですが、失敗ケースを見落とさないようにすることが重要です。最初に失敗ケースを考慮すると、より堅牢なコードにつながることがあります。\nExample # これの重要性を示すために、2つの数値を割る関数を考えてみましょう。GitHub Copilot は、成功ケースをカバーするテストケースを提案するかもしれません。しかし、分母がゼロの場合はどうでしょうか？\ndef divide(a, b): return a / b # Failure test case def test_divide_by_zero(): # \u0026lt;YOUR CODE AND GITHUB COPILOT SUGGESTION HERE\u0026gt; Exerecise # エクササイズ1: 2つの数字を掛ける関数を書き、成功ケースと失敗ケースの両方を含めてください（大きな数字の掛け算などのエッジケースを考慮してください） エクササイズ2: プロジェクト内の既存のコード片を分析し、欠落している失敗ケースを特定してください。これらのテストケースを書いてみましょう。 エクササイズ3: 次のプロジェクトでTDDのアプローチを実装し、実際の実装よりも先に失敗テストケースを書くようにし、これが開発プロセスにどのように影響するかを考えてみてください。 Checklist for Further Learning # 最近のコードで全ての潜在的な失敗ケースを考慮しましたか？ テストスイートに一貫して失敗テストケースを含めていますか？ チームがテストケースの作成においてTDDのマインドセットを採用するように、どのように促進できますか？ "},{"id":25,"href":"/ja/design-pattern/working-on-small-chunk/","title":"小さなコードチャンクで作業する","section":"Design-patterns","content":" 小さなまとまりで作業する # Description # 小さなコードの断片をより少ないコンテキストで扱うと、GitHub Copilot の出力が向上します。複雑なアプリケーションを構築していると想像してください。すべてを一度に生成しようとする代わりに、タスクを小さな部分に分割し、限定されたコンテキストを GitHub Copilot に提供します。このアプローチは開発プロセスを合理化するだけでなく、生成されたコードの品質も向上させます。\nコンテキストレスなアーキテクチャをデザインの段階で考慮するアイデアもありますが、すべてのプロジェクトで疎結合のアーキテクチャを適用することは難しいです。また、AIツールの精度を高めるためにアーキテクチャデザインを変えるのは本末転倒です。このパターンでは、少なくとも作業環境でコンテキストができるだけ小さくなるように、小さなチャンクで作業することによりGitHub Copilot の提案を向上させることを目的としています。GitHub Copilot が、全体的なプロジェクトの複雑さに圧倒されることなく、手がかりの具体的なタスクを理解できるようにする、よりコントロールされた、正確で、効率的なコード生成が可能です。\nExample # 複雑な計算する関数を書くとしましょう。GitHub Copilot に全体の複雑な解決策を求める代わりに、いくつかの関数に分けて、それぞれの関数を生成するように求めます。このアプローチは、GitHub Copilot がより小さなコンテキストで作業することを可能にし、より正確なコードを生成します。\ndef complex_calculation(n): # Ask GitHub Copilot to complete this function # Just write your code description by yourself class complex_calculation: def __init__(self, n): self.n = n def foo_calculation(self): # Ask GitHub Copilot to complete this function def bar_calculation(self): # Ask GitHub Copilot to complete this function Exercise # エクササイズ 1: 複雑なアルゴリズムを小さな部分に分割し、各部分のコードを GitHub Copilot で生成します。 エクササイズ 2: タスクのハイレベルの説明を書き、狭いコンテキストで GitHub Copilot にコードを求めます。結果を比較します。 エクササイズ 3: 個人的な開発プロセスを振り返り、タスクを小さなチャンクに分割することが有益であるエリアを特定します。 Checklist for Further Learning # コンテキストを絞り込むことが、GitHub Copilot の提案の精度にどのように影響しますか? GitHub Copilot により正確なコンテキストを提供するために、どのような戦略を使用できますか? GitHub Copilot の確率的な性質が、異なるシナリオでコードを生成する能力にどのように影響しますか? GitHub Copilot との小さなチャンクでの作業が、効果が少ないか、より困難である状況はありますか? "},{"id":26,"href":"/ja/general/regular-expression/","title":"正規表現","section":"Generals","content":" 正規表現 # {% hint style=\u0026ldquo;info\u0026rdquo; %} 現在のところ、LLMには複雑な正規表現を適切に表現する機能はありません。複雑なものについては、人間が補足的に入力しなければならないシーンが出てくるでしょう。一方で単純な正規表現には適用できます。 {% endhint %}\nDescription # GitHub Copilot は正規表現のパターンのドラフトを作成できます。以下では、文字列の検索や抽出に正規表現を使用する方法について説明します。2つの例を通して、GitHub Copilot が \u0026ldquo;入力/出力パターン\u0026rdquo; と \u0026ldquo;自然言語パターン\u0026rdquo; の両方で正規表現を生成する方法を示します。\nExample # 入力/出力パターン # 最初に、入力と出力を記述することで、GitHub Copilot は正規表現のパターンを作成できます。\nimport re # Write a regular expression # - Input: \u0026#34;Hello World\u0026#34; # - Output: [\u0026#34;H\u0026#34;, \u0026#34;W\u0026#34;] regex 結果として以下のようなコードを得ることができます。\nimport re # Write a regular expression # - Input: \u0026#34;Hello World\u0026#34; # - Output: [\u0026#34;H\u0026#34;, \u0026#34;W\u0026#34;] regex = r\u0026#34;[A-Z]\u0026#34; matched = re.findall(regex, \u0026#34;Hello World\u0026#34;) 自然言語パターン # 次に、正規表現で達成したい内容を自然言語で提供します。\nimport re # Write a regular expression # - \u0026#34;I have 3 apples and 2 oranges\u0026#34; like string, extract only the numbers to make an array sentence 結果として以下のようなコードを得ることができます。\nimport re # Write a regular expression # - \u0026#34;I have 3 apples and 2 oranges\u0026#34; like string, extract only the numbers to make an array sentence = \u0026#34;I have 3 apples and 2 oranges\u0026#34; regex = r\u0026#34;\\d+\u0026#34; matched = re.findall(regex, sentence) Exercise # エクササイズ: 文字列 \u0026ldquo;Hello World\u0026rdquo; から小文字のみを抽出します。 Checklist for Further Learning # 正規表現のパターンは、指定された文字列から正確な一致を抽出していますか? 現時点で、GitHub Copilot が使う 大規模言語モデルは、複雑な正規表現を適切に表現する能力を持っていません。複雑な正規表現を表現したい場合、どうしますか? GitHub Copilot をどのように活用して、それを構築するのをサポートし、支援しますか? "},{"id":27,"href":"/ja/client-tips/go-to-definition/","title":"定義に移動","section":"Client-tips","content":" 定義に移動 # {% hint style=\u0026ldquo;info\u0026rdquo; %} 2023年8月現在、GitHub Copilotはすべてのコードベースを読み込むわけではないので、このテクニックが必要になる場面が出てくるでしょう。一方、近い将来、GitHub Copilotでこのテクニックが不要になる可能性もあり、このテクニックは非常に限定的なものになるかもしれません。 {% endhint %}\nDescription # 複雑なコードベースで作業する際に、特定の関数やクラスの定義を見つけるためにファイル間をジャンプしたり、コードのレイヤーを検索するのは面倒です。\u0026ldquo;定義に移動\u0026rdquo; は、Visual Studio Code の便利な機能で、開発者が現在のファイル内の関数やクラスの定義にすばやく移動できるようにします。これによって生産性が向上するだけでなく、コード構造の理解も深まります。GitHub Copilot は開いているタブを読み取ります。\u0026ldquo;定義に移動\u0026rdquo; を使い実装を遡りながらファイルを開いていくことで、コードの奥深くにある定義に関連するコードスニペットも GitHub Copilot に渡すことができます。\nExample # Visual Studio Codeの \u0026ldquo;定義に移動\u0026rdquo; 機能を使用するには、調べたい関数やクラスを右クリックし、\u0026ldquo;定義に移動\u0026rdquo; を選択します。 ショートカット F12 も使用できます。以下のように行うことができます。\nExercise # エクササイズ 1: Visual Studio Code で複数のファイルを持つプロジェクトを開き、クラスまたは関数定義へ \u0026ldquo;定義に移動\u0026rdquo; を使用して移動してみましょう。 エクササイズ 2: 変数、メソッド、クラスなど、異なる関数やクラスシンボルで \u0026ldquo;定義に移動\u0026rdquo; 機能の使用を練習して、その多様性を理解しましょう。 Checklist for Further Learning # \u0026ldquo;定義に移動\u0026rdquo; 機能は、全体のコーディング体験をどのように向上させることができますか? \u0026ldquo;定義に移動\u0026rdquo; 機能と GitHub Copilot の統合は、コードナビゲーションと理解にどのようにさらに支援することができますか? この機能が開発ワークフローで特に有用である場合を特定できますか? "},{"id":28,"href":"/ja/design-pattern/eliminating-a-tiny-oss-dependency/","title":"微細な OSS 依存関係の排除","section":"Design-patterns","content":" 微細な OSS 依存関係の排除 # {% hint style=\u0026ldquo;info\u0026rdquo; %} これは限定的な適用かもしれません。より多くの事例が発見されれば、この成熟度レベルは上がっていきます。 {% endhint %}\nDescription # left-pad 問題をご存知ですか? 2016年に、left-pad ライブラリがnpmから停止され、それに依存するよく知られたライブラリが動作しなくなりました。left-pad は、指定された文字数、または指定されていない場合はスペースで、文字列の左側を埋めるだけのシンプルなJavaScriptライブラリです。空白行を除いて、約10行のシンプルなコードです。\n車輪の再発明を避けるための多くのアイデアがありますが、一方で、重大な影響を及ぼす可能性のある外部コードにも注意を払う必要があります。提供されたコードの範囲が非常に限られている場合、外部ソースに依存するよりも、内部に含める方が良いかもしれません。\nSamples # 以下のように、left-pad 関数を実装することができます:\ndef leftpad(string, length, char = \u0026#39; \u0026#39;) string.rjust(length, String(char)) end Exercise # エクササイズ 1: 文字列、長さ、パディングする文字を引数とする left-pad 関数を GitHub Copilot を使って実装します。デフォルトの文字はスペースであるべきです。 エクササイズ 2: プロジェクト内に複数の小さな外部依存関係が存在するシナリオを考えます。そのような依存関係を置き換えることができる小さなユーティリティ関数を特定し、実装します。 Checklist for Further Learning # 外部依存関係を使用するか、自分でコードを実装するかのトレードオフを考慮しましたか? この小規模な依存関係を排除するパターンが、コードの保守性にどのように影響する可能性がありますか? 小規模な外部依存関係を内部実装に置き換える際に使用できる原則やガイドラインは何ですか? "},{"id":29,"href":"/ja/testing/test-only-what-is-necessary/","title":"必要な部分だけをテストする","section":"Testings","content":" 必要な部分だけをテストする # {% hint style=\u0026ldquo;info\u0026rdquo; %} 不必要なテストケースを書く必要はありませんが、どのようなテストが必要かはチームによります。パターンとして具体化するには、より具体的な議論が必要です。 {% endhint %}\nDescription # 高速なソフトウェア開発の時代において、効率的で有益なテストの記述はこれまで以上に重要です。GitHub Copilotを使用する際に、開発者はカバレッジを増やすために多くのテストコードを生成してしまうかもしれません。しかし、不必要なテストコードの生成は保守の負担や技術的な負債を引き起こす可能性があります。GitHub Copilotを使用してテストコードを書く際には必要な部分のみをテストする事が重要です。\nExample # 特定の関数に対して意味のあるテストを書くことに重点を置くことで、カバレッジを上げるために複数のテストを書く代わりに、意味のあるテストを書くことが重要です。\n以下は不必要になりうるテストコードの例です:\nセッターやゲッターのテスト 言語の機能のテスト フレームワークの機能のテスト 定数のテスト 同じロジックを持つ冗長なテスト 些細なロジックのテスト サードパーティのライブラリのテスト ロジックのないランダムな値のテスト カバレッジを増やすだけでなく、また価値を追加しない数多くのテストを追加するのではなく、必要なテストのみを追加します。\nExercise # エクササイズ 1: 現在意味のないテストで過度にテストされているコードベース内の関数を特定し、必要なテストのみを含むようリファクタリングします。 エクササイズ 2: コードの重要な部分に新しいテストを書き、冗長性を避けて重要な側面に焦点を当てます。 エクササイズ 3: 現在のテストカバレッジを評価し、不可欠なカバレッジを失うことなくテストを削減できる領域を特定します。 Checklist for Further Learning # 機能を確実に検証するテストを書いているか、それとも単にカバレッジを上げるためのテストを書いていますか? 書いているテストがプロジェクトに価値を提供し、保守の負担を増やすだけでないことをどのように確認できますか? 特に GitHub Copilot などのツールを使用する際、テストスイートをスリムで意味のあるものに保つためにどのような戦略を取り入れることができますか? "},{"id":30,"href":"/ja/client-tips/pin-the-file-you-need/","title":"便利なファイルのピン留め","section":"Client-tips","content":" 便利なファイルのピン留め # Description # GitHub Copilot の性能は、提供されるコンテキストに依存します。GitHub Copilot はテキストの類似性で開いているタブを検索し、大規模言語モデルにスニペットを送信します。したがって、私たちは AI に提供したいコンテキストを慎重に考える必要があります。プログラミングでは、宣言ファイル（d.ts）、テストファイル、インターフェイスファイルなどが豊富なコンテキスト情報を含んでいます。Visual Studio Codeのピン留め機能を使用すると、これらのファイルを必要に応じて簡単にアクセスし、GitHub Copilotに効率的に情報を提供できます。\nExample # Visual Studio Codeでファイルをピン留めする方法は次のとおりです:\nピン留めしたいファイルを開きます。 ファイルタブ上で右クリックします。 コンテキストメニューから\u0026quot;Pin Tab\u0026quot;を選択します。 Exercise # エクササイズ 1: 現在のプロジェクトで宣言ファイル（例: .d.tsファイル）をピン留めし、GitHub Copilotと一緒に作業する際にアクセスが容易になることに注目してください。 エクササイズ 2: 新しいインターフェイスファイルを作成し、ピン留めします。GitHub Copilotがこのファイルをどのように利用してより良いコード提案ができるのか探究してください。 エクササイズ 3: プロジェクト内で複数のテストファイルをピン留めし、Copilotの助けを借りて新しいテストケースを書く際にどのように助けになるか観察してください。 Checklist for Further Learning # ピン留めするファイルの種類を変えると、GitHub Copilot との作業フローにどのような影響がありますか? Visual Studio Codeの他の機能は、GitHub Copilot との経験を向上させるためにどう活用できますか? 大量のピン留めファイルを管理して、常に GitHub Copilot に適切なコンテキストが利用可能であるようにするにはどうすればよいですか? "},{"id":31,"href":"/ja/general/showing-examples/","title":"例示によるコード生成","section":"Generals","content":" 例示によるコード生成 # Description # GitHub Copilotを使用して、開発者は提供された例に基づいてコードを生成できます。特定の出力を生成するコードが期待される場合、これは非常に便利です。このパターンでは、例としてJSONを生成するなど、Ruby on Rails のモデルを作成する方法を探ります。\nExample # 以下のサンプルは、コメント内で例を提供し、GitHub Copilot に対応するモデルを作成する Ruby on Rails コードを生成するように頼む方法を示しています。\n# 以下のJSONを作成するコード生成の例: # { # \u0026#34;name\u0026#34;: \u0026#34;John Smith\u0026#34;, # \u0026#34;age\u0026#34;: 30, # \u0026#34;description\u0026#34;: \u0026#34;これはサンプルの説明です。\u0026#34;, # \u0026#34;country\u0026#34;: \u0026#34;Japan\u0026#34;, # \u0026#34;title\u0026#34;: \u0026#34;Customer Success Architect\u0026#34;, # \u0026#34;email\u0026#34;: \u0026#34;johnsmith@example.com\u0026#34; # } rails g model users name:string age:integer description:text country:string title:string email:string Exercise # エクササイズ 1: 以下の例に基づいて、書籍のモデルを作成する Ruby on Rails のコードを生成してください。 { \u0026#34;title\u0026#34;: \u0026#34;Book\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Jane Doe\u0026#34;, \u0026#34;price\u0026#34;: 19.99 } エクササイズ 2: JSONの例で異なる属性とタイプを試し、対応する Rails のモデル生成コードを生成してください。 エクササイズ 3: Rails プロジェクトで生成されたコードをテストし、期待されるモデルを作成することを確認してください。 Checklist for Further Learning # 生成されたコードは、与えられた例を正確に反映し、適切なコードを作成していますか? 提供された例からコードを生成する際の主要な考慮点や課題は何でしたか? 特定のプロジェクト要件に合わせて、生成されたコードをさらにカスタマイズまたは最適化するにはどうすればよいですか? "}]