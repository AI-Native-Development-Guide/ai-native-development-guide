<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Refactorings on GitHub Copilot Patterns &amp; Exercises</title><link>/ja/refactoring/</link><description>Recent content in Refactorings on GitHub Copilot Patterns &amp; Exercises</description><generator>Hugo -- gohugo.io</generator><language>ja</language><atom:link href="/ja/refactoring/index.xml" rel="self" type="application/rss+xml"/><item><title>オープン・クエスチョンで尋ねる</title><link>/ja/refactoring/asking-with-open-ended-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/refactoring/asking-with-open-ended-questions/</guid><description>オープン・クエスチョンで尋ねる Description リファクタリングは、しばしば複雑なプロセスであります。必ずしも何が正しく、何が間違っているかについてではなく、基本概念と潜在的な改善を理解することが重要です。GitHub Copilotでオープン・クエスチョンを利用することで、開発者は GitHub Copilot の助けを借りてより熟慮した方法でコードの改善に取り組むことができます。
Example GitHub Copilotでのクエリに開かれた質問を導入すると、洞察に満ちた提案が得られることがあります。例えば:
// Q: この関数の復元性をどのように改善できますか? // A: &amp;lt;GITHUB COPILOT SUGGESTION&amp;gt; function backupData(data) { // 実装はこちら } // Q: この文脈でエラーを処理する最良の方法は何ですか? // A: &amp;lt;GITHUB COPILOT SUGGESTION&amp;gt; try { // 何かの操作 } catch (error) { // エラー処理 } Exercise エクササイズ 1: ファイルハンドリングに関連する関数を記述し、それをより信頼性があり効率的にする方法について Copilot に尋ねてみてください。 エクササイズ 2: 例外処理を含むコードスニペットを作成し、エラー報告の改善について Copilot に提案を求めてください。 エクササイズ 3: シンプルな UI コンポーネントを設計し、それに対するアクセスや操作をよりエレガントにする方法について Copilot に尋ねてみてください。 Checklist for Further Learning 既存のコードのどの部分がリファクタリングから利益を得ることができますか? オープンクエスチョンが開発プロセスでどのように機能しますか?</description></item><item><title>リファクタリング前にテストコードを書く</title><link>/ja/refactoring/writing-test-code-before-refactoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/refactoring/writing-test-code-before-refactoring/</guid><description>リファクタリング前にテストコードを書く Description ソフトウェア開発の現代世界において、GitHub Copilotのようなツールが手元にあると、リファクタリングは楽しく魅力的なタスクになるかもしれません。変更を加えることは非常に簡単ですが、適切なテストがない場合、最も有望なコードの変更でも予期せぬ結果につながることがあります。このパターンは、コードをリファクタリングする前にテストを記述して機能が一貫していることを確認する重要性を強調しています。テストを安全ネットと考えてください。問題が深刻化する前に問題を検出します。
Example ショッピングカートの合計価格を計算する関数があるとし、これをより明確にリファクタリングしたいと考えたとします。以下は元のコードです:
def total_price(items): return sum(item[&amp;#39;price&amp;#39;] * item[&amp;#39;quantity&amp;#39;] for item in items) リファクタリング前に、既存の機能が保持されていることを確認するためにテストを記述します:
def test_total_price(): items = [ {&amp;#39;price&amp;#39;: 5, &amp;#39;quantity&amp;#39;: 2}, {&amp;#39;price&amp;#39;: 3, &amp;#39;quantity&amp;#39;: 1} ] assert total_price(items) == 13 これでコードをリファクタリングして、可読性を向上させることができます:
def total_price(items): total = 0 for item in items: total += item[&amp;#39;price&amp;#39;] * item[&amp;#39;quantity&amp;#39;] return total テストはまだ合格しますので、リファクタリングによって期待される結果が変わっていないことを保証します。
Exercise エクササイズ 1: リファクタリングが必要な関数を記述し、それに対応するテストを記述します。 エクササイズ 2: テストが合格することを確認しながら関数をリファクタリングします。 エクササイズ 3: リファクタリングした関数に誤った変更を加えてエラーが発生する状況を模倣し、テストがエラーを検出する過程を観察します。 Checklist for Further Learning コードの重要な側面をすべてカバーするためにテストがどのように確認されますか? 選択したプログラミング言語で、テストを記述して実行するためのツールやフレームワークは何ですか? リファクタリング時にテスト駆動開発（TDD）のプラクティスをどのように適用できますか? テストを整理するためのベストプラクティスは何ですか?</description></item><item><title>計算ロジックを独立させる</title><link>/ja/refactoring/making-the-calculation-part-independent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/refactoring/making-the-calculation-part-independent/</guid><description>計算ロジックを独立させる Description ソフトウェア開発の急速に進化する世界で、GitHub Copilot のようなツールに頼ることで、開発プロセスを強化できます。しかし、複雑な計算を行う際、大規模言語モデルの現行バージョンには限界があるかもしれません。これに対処するため、開発者は計算部分を別の関数に移動してコードをリファクタリングすることができます。これにより、コードの保守性、可読性が向上し、さらに AI ツールをつかったテストや開発が容易になります。金融ソフトウェアシステムを構築している開発者が、利息計算をユーザーインターフェイスロジックから分離する必要がある場合を想像してみてください。毎回 GitHub Copilot が特定のコードを書き換えるたびにロジックが正しいかを検証するのは非常に厄介な作業です。この複雑な計算を分離することで、柔軟でより耐久性のある AI と協働できるコードベースを作成します。
Example 計算と注文合計の処理
計算ロジックが他の機能と混ざっていた場合は以下のようになります。
def handle_order(order_items): tax_rate = 0.05 total = 0 for item in order_items: total += item[&amp;#39;price&amp;#39;] total += total * tax_rate process_payment(total) ship_order(order_items) return total 一方で、計算ロジックを別の関数に移動すると、以下のようになります。
def calculate_total(order_items, tax_rate=0.05): subtotal = sum(item[&amp;#39;price&amp;#39;] for item in order_items) total = subtotal + (subtotal * tax_rate) return total def handle_order(order_items): total = calculate_total(order_items) process_payment(total) ship_order(order_items) return total ここで、calculate_total 関数は注文合計に関連するすべての計算を処理し、handle_order 関数は支払いの処理や注文の発送など、他の関連機能を処理します。</description></item></channel></rss>