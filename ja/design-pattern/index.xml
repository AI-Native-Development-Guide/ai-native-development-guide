<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design-patterns on GitHub Copilot Patterns &amp; Exercises</title><link>/ja/design-pattern/</link><description>Recent content in Design-patterns on GitHub Copilot Patterns &amp; Exercises</description><generator>Hugo -- gohugo.io</generator><language>ja</language><atom:link href="/ja/design-pattern/index.xml" rel="self" type="application/rss+xml"/><item><title>AI が理解可能な命名規則</title><link>/ja/design-pattern/ai-readable-naming-convention/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/design-pattern/ai-readable-naming-convention/</guid><description>AIが読み取り可能な命名規則 # Description # AIが理解可能な命名規則のパターンは、GitHub Copilotのような AI ツールがもっと読みやすくするためにコード内の変数と関数の命名方法に焦点を当てます。一般的でありふれたプログラミング名や、x や y のような適当な命名を避け、具体的で説明的な名前を採用することで、人間の開発者と GitHub Copilot を動かすAIモデルの両方が容易に理解できるコードを作ります。
例えば、図書館システムを作るエンジニアは、システムの変数名や関数名に「辞書(=dictionary)」「ライブラリ(=library)」「本棚(=stack)」といった一般的な言葉を使うかもしれません。しかし、&amp;ldquo;dictionary&amp;quot;という名前を含む変数の本当の型が配列だったらどうでしょう。これはほんの一例ですが、GitHub Copilotはこうしたことが積み重なると間違った答えを提案することがあります。 さらに文脈を示す必要がある場合は、言語のタイプヒンティングを用いるか、コメントとして文脈を追加するのがよいでしょう。
このパターンに従うことで、GitHub Copilotの効果を高め、より正確なサジェストと開発者の速度向上につながります。
Example # ここでは、異なる命名規則がコードの明快さと正確さにどのような影響を与えるかを示す3つの例を紹介します:
Ambiguous Naming:
# This may confuse whether &amp;#34;dictionary&amp;#34; refers to a book or a data type dictionary = Better Naming with Comments:
# sample list of dictionaries in the library, like &amp;#34;Oxford&amp;#34; and &amp;#34;Cambridge&amp;#34; library_dictionaries = [&amp;#34;Merriam-Webster&amp;#34;, &amp;#34;Oxford&amp;#34;, &amp;#34;Cambridge&amp;#34;] Specific Naming with Type Hinting:
from typing import List # A clear and specific variable name with type hinting list_of_dictionaries_in_library: List[str] = [&amp;#34;Merriam-Webster&amp;#34;, &amp;#34;Oxford&amp;#34;, &amp;#34;Cambridge&amp;#34;] Exercise # エクササイズ 1: 現在のコードベースを見直し、非記述的な方法で名前が付けられている可能性のある変数や関数を特定します。それらをAIが読み取り可能な命名規則に従ってリネームしてみてください。 エクササイズ 2: 新しい命名パターンで GitHub Copilot を使用して実験し、変更前後の提案と精度を比較してみてください。 エクササイズ 3: この命名規則を念頭に置いて新しいコードを書いてみて、Copilotがコードにどのように反応するかを観察してみてください。 エクササイズ 4: チーム向けに AI の可読性に焦点を当てた命名規則ガイドラインを作成し、チームのコーディング標準に組み込んでみてください。 エクササイズ 5: チームにこれらの命名規則の使用を奨励し、全体のコードの可読性と GitHub Copilot の効果に対する影響を時間をかけて観察してみてください。 Further Learningのチェックリスト # 人間の開発者とAIモデルの両方にコードをもっと読みやすくするにはどうすればいいですか?</description></item><item><title>コンテキストレス・アーキテクチャ</title><link>/ja/design-pattern/context-less-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/design-pattern/context-less-architecture/</guid><description>コンテキストレス・アーキテクチャ # {% hint style=&amp;ldquo;info&amp;rdquo; %} 疎結合アーキテクチャ自体も多くの場合推奨されており、このパターンはその考え方に合致しています。しかし、AIを活用した開発の文脈をより広範なアーキテクチャの議論と結びつけ、それを正当化するためには、より多くの議論が必要です。ぜひディスカッションを始めましょう! {% endhint %}
Description # コンテキストレス・アーキテクチャは、システム内のより小さく、明確に定義されたコンテキストにコーディングを限定するデザインパターンです。複雑なプログラムを疎結合で独立したコンポーネントに分割することで、このアーキテクチャは保守性、拡張性、柔軟性を向上させます。
GitHub Copilot のような AIツールと連携する際、その性質と制限を理解することが不可欠です。現在の GitHub Copilot は AGI (Artificial General Intelligence) ではないため、限定された正確なコンテキスト内で最も効果的に動作します。特定のニーズに焦点を当てることで、開発者は GitHub Copilot の正確性と効率を最大化することができます。
キーとなるのは、各コンポーネントが特定の目的に役立つ疎結合なシステムを作成することです。このアプローチは GitHub Copilot の制限と合致しており、開発者がツールをより効果的に使用して、モジュラーで堅牢なソフトウェアを構築することができます。 一方で、ツールにあわせてシステムのデザインを決めることは本質的なことではありません。 このパターンは現実のプロジェクトやプロダクトにおいて、疎結合であることが意味を成す場合に、AI の開発における活用を追加で考えることで、より効果的に開発速度が上がることを目的としています。
Example # Before # ここでは、ユーザー管理と認証が混ざり合っており、コンテキストが不明確で絡み合っています。
class UserManager: def create_user(self, username, password): # Code to create user pass def login(self, username, password): # Code to handle login pass def update_user_profile(self, user_id, profile_data): # Code to update user profile pass After # コンテキストレス アーキテクチャを適用することで、ユーザー管理と認証が明確なコンテキストに分離されます。</description></item><item><title>ハイレベルアーキテクチャを先に</title><link>/ja/design-pattern/high-level-architecture-first/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/design-pattern/high-level-architecture-first/</guid><description>ハイレベルアーキテクチャを先に # Description # 複雑なシステムを開発するとき、いきなり細部のコードに飛び込み、プログラムの全体的なアーキテクチャを見失うことはよくあることです。このような事が繰り返されると、同時に GitHub Copilot も全体的なアーキテクチャを見失うことに繋がります。これは誤解やエラーの原因となってしまいます。開発において、プログラムのハイレベルなアーキテクチャを先に設計し、コードの各部分の機能と目的についてコメントしていくことにより、GitHub Copilot も文脈をよりよく理解し、より的確な提案をすることができます。
Example # ウェブアプリケーションでのAPIエンドポイントファイルを考えてみましょう。初期に設計を自然言語で提案することは、各エンドポイントの機能を GitHub Copilot に理解させるのに役立ちます。
# GET /items # - アイテムのリストを取得します。 # - 応答でアイテムのコレクションを返します。 # # POST /items # - 新しいアイテムを作成し、コレクションに追加します。 # - リクエストでアイテムのパラメーターが必要です。 # - 成功時に成功メッセージとともにカートページにリダイレクトします。 # - 失敗した場合、新しいアイテムのフォームを表示します。 # # GET /items/:id # - 特定のIDを持つアイテムを取得します。 # - URLパラメーターとしてアイテムのIDが必要です。 # - 応答で要求されたアイテムの詳細を返します。 # ... Exercise # エクササイズ: バックエンドの簡単な API について、各エンドポイントに対するコメントを含め、ログインと登録システムのハイレベルアーキテ クチャのアウトラインを作成します。 Checklist for Further Learning # コードの詳細を書く前に明確なロードマップを確立しましたか? GitHub Copilot は、ハイレベルのコメントを読むだけで、ファイルの目的を理解できますか?</description></item><item><title>一貫性のあるコーディングスタイル</title><link>/ja/design-pattern/consistent-coding-style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/design-pattern/consistent-coding-style/</guid><description> 一貫性のあるコーディングスタイル # Description # 一貫性のあるコーディングスタイルは、ソフトウェア開発において非常に重要です。それはコードの可読性を向上させるだけでなく、GitHub Copilot からのより良い提案にもつながります。インデント、タブ、命名規則、コメントの書き方、言語固有の省略方法など、コーディングスタイルの領域は多岐にわたります。一様なコーディングスタイルとパターンに従うことで、開発者は優れたコーディング慣行に従いやすくなります。
Example # 以下は、明確な関数名を使用し、コードベースのパターンに従う良い例です（snake_case を使用）:
def calculate_area(length, width): return length * width これと一貫性のないコーディングスタイルを比較してみてください。一貫性が無いコードの場合、GitHub Copilot から以下のような存在しない関数の提案をもらうことに繋がる可能性があります。
def calcSomething(l, w): area = calcArea(l, w) # &amp;lt;Code goes here&amp;gt; Exercise # エクササイズ 1: 記述的で一貫性のある命名規則を使用して関数を書く練習をします。 エクササイズ 2: コードスニペットを分析し、コーディングスタイルの非一貫性を特定します。必要な調整をします。 エクササイズ 3: GitHub Copilot を使用して小さなプロジェクトを作成し、異なるコーディングスタイルへの反応を観察します。 Checklist for Further Learning # 一貫性のあるコーディングスタイルは、コードベースの可読性と保守性にどう影響しますか? チームやプロジェクト内でコーディング基準を強制するために、どのようなコミュニケーションが必要ですか? GitHub Copilot は、コーディングのベストプラクティスをどのように支援しますか? どのような行動を促進または抑制しますか?</description></item><item><title>小さなコードチャンクで作業する</title><link>/ja/design-pattern/working-on-small-chunk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/design-pattern/working-on-small-chunk/</guid><description>小さなまとまりで作業する # Description # 小さなコードの断片をより少ないコンテキストで扱うと、GitHub Copilot の出力が向上します。複雑なアプリケーションを構築していると想像してください。すべてを一度に生成しようとする代わりに、タスクを小さな部分に分割し、限定されたコンテキストを GitHub Copilot に提供します。このアプローチは開発プロセスを合理化するだけでなく、生成されたコードの品質も向上させます。
コンテキストレスなアーキテクチャをデザインの段階で考慮するアイデアもありますが、すべてのプロジェクトで疎結合のアーキテクチャを適用することは難しいです。また、AIツールの精度を高めるためにアーキテクチャデザインを変えるのは本末転倒です。このパターンでは、少なくとも作業環境でコンテキストができるだけ小さくなるように、小さなチャンクで作業することによりGitHub Copilot の提案を向上させることを目的としています。GitHub Copilot が、全体的なプロジェクトの複雑さに圧倒されることなく、手がかりの具体的なタスクを理解できるようにする、よりコントロールされた、正確で、効率的なコード生成が可能です。
Example # 複雑な計算する関数を書くとしましょう。GitHub Copilot に全体の複雑な解決策を求める代わりに、いくつかの関数に分けて、それぞれの関数を生成するように求めます。このアプローチは、GitHub Copilot がより小さなコンテキストで作業することを可能にし、より正確なコードを生成します。
def complex_calculation(n): # Ask GitHub Copilot to complete this function # Just write your code description by yourself class complex_calculation: def __init__(self, n): self.n = n def foo_calculation(self): # Ask GitHub Copilot to complete this function def bar_calculation(self): # Ask GitHub Copilot to complete this function Exercise # エクササイズ 1: 複雑なアルゴリズムを小さな部分に分割し、各部分のコードを GitHub Copilot で生成します。 エクササイズ 2: タスクのハイレベルの説明を書き、狭いコンテキストで GitHub Copilot にコードを求めます。結果を比較します。 エクササイズ 3: 個人的な開発プロセスを振り返り、タスクを小さなチャンクに分割することが有益であるエリアを特定します。 Checklist for Further Learning # コンテキストを絞り込むことが、GitHub Copilot の提案の精度にどのように影響しますか?</description></item><item><title>微細な OSS 依存関係の排除</title><link>/ja/design-pattern/eliminating-a-tiny-oss-dependency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/ja/design-pattern/eliminating-a-tiny-oss-dependency/</guid><description> 微細な OSS 依存関係の排除 # {% hint style=&amp;ldquo;info&amp;rdquo; %} これは限定的な適用かもしれません。より多くの事例が発見されれば、この成熟度レベルは上がっていきます。 {% endhint %}
Description # left-pad 問題をご存知ですか? 2016年に、left-pad ライブラリがnpmから停止され、それに依存するよく知られたライブラリが動作しなくなりました。left-pad は、指定された文字数、または指定されていない場合はスペースで、文字列の左側を埋めるだけのシンプルなJavaScriptライブラリです。空白行を除いて、約10行のシンプルなコードです。
車輪の再発明を避けるための多くのアイデアがありますが、一方で、重大な影響を及ぼす可能性のある外部コードにも注意を払う必要があります。提供されたコードの範囲が非常に限られている場合、外部ソースに依存するよりも、内部に含める方が良いかもしれません。
Samples # 以下のように、left-pad 関数を実装することができます:
def leftpad(string, length, char = &amp;#39; &amp;#39;) string.rjust(length, String(char)) end Exercise # エクササイズ 1: 文字列、長さ、パディングする文字を引数とする left-pad 関数を GitHub Copilot を使って実装します。デフォルトの文字はスペースであるべきです。 エクササイズ 2: プロジェクト内に複数の小さな外部依存関係が存在するシナリオを考えます。そのような依存関係を置き換えることができる小さなユーティリティ関数を特定し、実装します。 Checklist for Further Learning # 外部依存関係を使用するか、自分でコードを実装するかのトレードオフを考慮しましたか? この小規模な依存関係を排除するパターンが、コードの保守性にどのように影響する可能性がありますか? 小規模な外部依存関係を内部実装に置き換える際に使用できる原則やガイドラインは何ですか?</description></item></channel></rss>