[{"id":0,"href":"/CONTRIBUTING/","title":"Contributing","section":"","content":" Contributing to GitHub Copilot Patterns \u0026amp; Exercises # The goal of the GitHub Copilot Patterns \u0026amp; Exercises Working Group is to collect, document, and publish best practices for GitHub Copilot Patterns \u0026amp; Exercises. To ensure they are easy to understand, evaluate, and apply, we present them in a specific structure.\nWe welcome your participation, whether you make minor or major contributions, to help this working group function actively.\nHow to Contribute # Please consider contributing to GitHub Copilot Patterns \u0026amp; Exercises. Below are some suggestions on how you can contribute.\nShare opinions and encourage discussion: Fresh perspectives, intriguing thoughts, or early novel ideas can provoke discussions and lead to unexpected outcomes. Please create Issues to share your opinions on GitHub Copilot Patterns \u0026amp; Exercises-related topics at any time. Read existing patterns and improve them: We recommend starting by exploring the existing patterns and materials in this repository. Did you spot a confusing phrase or incorrect grammar? Is there a content error? Create a GitHub Issue or suggest a correction directly via a pull request. Verify the use of patterns: Confirming that multiple organizations have adopted a pattern increases its significance and reassures potential adopters that the pattern is reliable. If you\u0026rsquo;re implementing any of the published patterns, list your organization as a known example of that pattern and describe your experience in applying it. Translate existing patterns: When introducing GitHub Copilot Patterns \u0026amp; Exercises in your area, a language barrier might deter individuals since most GitHub Copilot Patterns \u0026amp; Exercises content is in English. Thus, translating them to cater to your region or organization is invaluable. For guidelines on translating patterns into other languages, please consult the translation instructions. Review open pull requests: Even if you\u0026rsquo;re unfamiliar with all the details of the Patterns Working Group, feedback on existing pull requests, especially those proposing changes to pattern content, is immensely helpful to their authors. Whether you\u0026rsquo;re new to GitHub Copilot Patterns \u0026amp; Exercises or have some experience, your insights are valuable. Contribute to new patterns: A significant contribution is documenting the best practices of GitHub Copilot Patterns \u0026amp; Exercises that you\u0026rsquo;re familiar with or have experienced. Content in this repository has specified maturity levels. First-time contributors should target Maturity Level 1: Initial (unstructured experience reports or patterns with incomplete sections) and 2: Structured (best practices adhering to the pattern format and basic textual representation rules). Become a pattern advocate: Introducing more individuals with varied perspectives and experiences enriches the patterns. If a colleague has shared an innovative GitHub Copilot Patterns \u0026amp; Exercises best practice with you, encourage them to contribute to this repository! How to Contact # Please don\u0026rsquo;t hesitate to reach out for assistance in contributing to GitHub Copilot Patterns \u0026amp; Exercises or simply to chat. The most straightforward method to contact us is through Discord.\nLicensing Contributions # This repository\u0026rsquo;s content is licensed under CC-BY-SA-4.0. When contributing, you grant us, and everyone else, permission to use your contribution under this license.\nAcknowledging Contributions # If you list yourself as the author of a pattern, we assume that you consent to be mentioned when referencing that pattern.\nCode of Conduct # While we don\u0026rsquo;t have a fully formalized code of conduct yet, we expect all contributors to show mutual respect and help maintain a community free of harassment and discrimination.\n"},{"id":1,"href":"/menu/","title":"Index","section":"","content":" About\nIntroduction Contributing to the Project General\nCode completion Comment to code Code to comment Quick Q\u0026amp;A Regular expression Language translation Type hinting Code to document Object generation from structured data Showing examples Client Side Tips\nCopilot snippet handling GitHub Copilot Shortcuts Go to definition Pin the files you need Design Patterns\nAI readable naming convention Consistent coding style High-level architecture first Working on small chunks Context-less Architecture Eliminating a tiny OSS dependency Collaboration\nAI friendly documentation Coaching on prompts Test\nCreating unit tests Specify how to generate test code Writing failure case first Writing test cases in natural language first Test only what is necessary Refactoring\nWriting test code before refactoring Making the calculation part independent Asking with open-ended questions Archived Version\nEnglish ðŸ‡¬ðŸ‡§ German ðŸ‡©ðŸ‡ª Spanish ðŸ‡ªðŸ‡¸ French ðŸ‡«ðŸ‡· Italy ðŸ‡®ðŸ‡¹ Japanese ðŸ‡¯ðŸ‡µ Portuguese ðŸ‡µðŸ‡¹ Chinese ðŸ‡¨ðŸ‡³ GitHub\n"},{"id":2,"href":"/SUMMARY/","title":"Summary","section":"","content":" Table of Contents # Introduction Contributing to the Project General # Code completion Comment to code Code to comment Quick Q\u0026amp;A Regular expression Language translation Type hinting Code to document Object generation from structured data Showing examples Client Side Tips # Copilot snippet handling GitHub Copilot Shortcuts Go to definition Pin the files you need Design Patterns # AI readable naming convention Consistent coding style High-level architecture first Working on small chunks Context-less Architecture Eliminating a tiny OSS dependency Collaboration # AI friendly documentation Coaching on prompts Test # Creating unit tests Specify how to generate test code Writing failure case first Writing test cases in natural language first Test only what is necessary Refactoring # Writing test code before refactoring Making the calculation part independent Asking with open-ended questions Archived # GitHub Copilot Patterns \u0026amp; Exercises Guide Translations German ðŸ‡©ðŸ‡ª Spanish ðŸ‡ªðŸ‡¸ French ðŸ‡«ðŸ‡· Italy ðŸ‡®ðŸ‡¹ Japanese ðŸ‡¯ðŸ‡µ Portuguese ðŸ‡µðŸ‡¹ Chinese ðŸ‡¨ðŸ‡³ "},{"id":3,"href":"/collaboration/ai-friendly-documentation/","title":"AI friendly documentation","section":"Collaborations","content":" AI-friendly documentation # Description # In the era of GitHub Copilot, an AI powered coding assistance tool, having easily accessible documents in text format becomes crucial. In the AI era, files such as Infrastructure as Code, database table specifications, test requirements, and more have the potential to be instantly transformed into actual code. Rather than dealing with complex Excel, PowerPoint files, PDFs, or image formats, AI will be able to assist your coding efforts collaboratively through text-based documents.\nLet\u0026rsquo;s check if the following files are text-based or AI friendly:\nInfrastructure definitions Database table definitions Test specifications Example # Infrastructure Definitions Database Table Definitions Test Specifications For example, if you have a table written in markdown like below, GitHub Copilot can use it as a base for migration files and interface files.\n# | No. | Item Name | Type | Length | Decimal | Required | Primary Key | Remarks | # | --- | -------------------- | --------------------------- | ------ | ------- | -------- | ----------- | ---------------------- | # | 1 | pass_document_id | integer | | | Y | Y | Document ID | # | 2 | checkout_id | integer | | | Y | Y | Unique Serial Number | # | ... | ... | ... | ... | ... | ... | ... | ... | # | 15 | update_datetime | timestamp-without-time-zone | | | | | Update Timestamp | # Create migration file of cooperation_pass public class CreateGovernmentPass \u0026lt; ActiveRecord::Migration[7.0] def change # \u0026lt;Copilot Suggestion Here\u0026gt; Exercise # Exercise 1: Check your existing documentation and list the files that are not in text-based formats. Exercise 2: Convert one of the non-text-based files into a markdown or plaintext file and compare its accessibility with the previous format. Exercise 3: Write a script that scans your repository and alerts you if non-text-based documentation is committed. Checklist for Further Learning # How can you ensure that team members are adhering to text-based documentation standards? What other team/project documentation could be written in text to speed up development? How can the adoption of text-based documentation improve development using the AI tool GitHub Copilot? "},{"id":4,"href":"/design-pattern/ai-readable-naming-convention/","title":"AI readable naming convention","section":"Design-patterns","content":" AI readable naming convention # Description # The AI readable naming convention focuses on the way we name variables and functions in our code to make them more readable by AI tools like GitHub Copilot. By avoiding generic and common programming names and embracing specific, descriptive names, we create code that both human developers and AI models which powers Copilot, can easily comprehend.\nFor example, an engineer creating a library system may use generic words such as \u0026ldquo;dictionary\u0026rdquo;, \u0026ldquo;library\u0026rdquo;, and \u0026ldquo;stack\u0026rdquo; for system variable names and function names. But what if the real type of the variable named \u0026ldquo;dictionaries\u0026rdquo; was an array? This is just an example, but GitHub Copilot may give the wrong answer when these things pile up. If you need to provide more context, it\u0026rsquo;s a good idea to type hint or use comments to add context.\nBy following this pattern, we enhance the effectiveness of GitHub Copilot, leading to more accurate suggestions and increased developers\u0026rsquo; velocity.\nExample # Here are three examples that illustrate how different naming conventions can impact the clarity and accuracy of the code:\nAmbiguous Naming:\n# This may confuse whether \u0026#34;dictionary\u0026#34; refers to a book or a data type dictionary = Better Naming with Comments:\n# sample list of dictionaries in the library, like \u0026#34;Oxford\u0026#34; and \u0026#34;Cambridge\u0026#34; library_dictionaries = [\u0026#34;Merriam-Webster\u0026#34;, \u0026#34;Oxford\u0026#34;, \u0026#34;Cambridge\u0026#34;] Specific Naming with Type Hinting:\nfrom typing import List # A clear and specific variable name with type hinting list_of_dictionaries_in_library: List[str] = [\u0026#34;Merriam-Webster\u0026#34;, \u0026#34;Oxford\u0026#34;, \u0026#34;Cambridge\u0026#34;] Exerecise # Exercise 1: Review your current codebase and identify variables or functions that may be named in a non-descriptive way. Try to rename them following the AI readable naming convention pattern. Exercise 2: Experiment with using GitHub Copilot with the new naming pattern, and compare the suggestions and accuracy before and after the change. Exercise 3: Write a new piece of code with these naming conventions in mind, and observe how Copilot responds to the code as you write it. Exercise 4: Create a naming convention guideline for your team, focusing on AI readability, and integrate it into your team\u0026rsquo;s coding standards. Exercise 5: Encourage the team to use these naming conventions and observe the impact on overall code readability and GitHub Copilot effectiveness over time. Checklist for Further Learning # How can I make my code more readable to both human developers and AI models? Are there any specific cases where this naming pattern may not apply or be counterproductive? "},{"id":5,"href":"/refactoring/asking-with-open-ended-questions/","title":"Asking with open-ended questions","section":"Refactorings","content":" Asking with Open-Ended Questions # Description # Refactoring is often a complex process. It is not necessarily about what is right and what is wrong, but about understanding the basic concepts and potential improvements. using open questions in GitHub Copilot, developers can work on improving code in a more thoughtful way with the help of GitHub Copilot GitHub Copilot can help developers work on code improvements in a more thoughtful way.\nExample # Introducing open-ended questions in your queries with GitHub Copilot can lead to insightful suggestions. For example:\n// Q: How can I improve the restorability of this function? // A: \u0026lt;GITHUB COPILOT SUGGESTION\u0026gt; function backupData(data) { // Implementation here } // Q: What\u0026#39;s the best way to handle errors in this context? // A: \u0026lt;GITHUB COPILOT SUGGESTION\u0026gt; try { // Some operation } catch (error) { // Error handling } Exercise # Exercise 1: Write a function related to file handling and ask Copilot how to make it more reliable and efficient. Exercise 2: Create a code snippet that includes exception handling and ask Copilot for suggestions to improve error reporting. Exercise 3: Design a simple UI component and ask Copilot how to access or manipulate it in a more elegant way. Checklist for Further Learning # What other areas of your code can benefit from refactoring? How can open-ended questions assist in your development process? "},{"id":6,"href":"/collaboration/coaching-on-prompts/","title":"Coaching on Prompts and Code Generating Process","section":"Collaborations","content":" Coaching on Prompts and Code Generating Process # {% hint style=\u0026ldquo;info\u0026rdquo; %} While this sounds reasonable, it is not a systematic or established pattern. {% endhint %}\nDescription # Using an AI tool like GitHub Copilot can make the output look cleaner than it should. Code that looks perfect when you review it may actually be inefficient in the generation process or missing something important. Coaching on the generative process becomes essential to ensure that developers are aware of potential pitfalls and can create efficient and accurate code.\nIn modern software development, coaching is more than just a review; it\u0026rsquo;s an opportunity to guide, inspire, and improve. This pattern emphasizes coaching peers on the quality of prompts used in code generation, particularly with AI-driven tools like GitHub Copilot. Coaching aims to enhance not only the prompts but also the understanding of the generative process.\nExample # Imagine a scenario where a teammate has created a prompt to generate code for a specific task. Your role is to provide coaching to improve the prompt\u0026rsquo;s clarity and understand the underlying generative process.\nOriginal Prompt:\n\u0026#34;Create a function to find prime numbers within a range.\u0026#34; Coached Prompt:\n\u0026#34;Develop a Python function that takes two integers as input and returns a list of prime numbers within that range. Ensure the function efficiently handles different ranges, including edge cases.\u0026#34; Exercise # Exercise 1: Provide coaching on a prompt from your teammate. Identify areas for enhancement, give insights into the generative process, and explain why the changes are beneficial. Exercise 2: Analyze a code snippet previously generated by GitHub Copilot, focusing on both the prompt and the underlying generative process. Offer coaching on how it could be more specific and efficient. Exercise 3: Practice crafting your own prompts for various programming scenarios. Engage with peers for coaching, emphasizing both the quality of prompts and the understanding of the code generation process. Checklist for Further Learning # Have I recognized the distinction between mere reviewing and coaching for continuous improvement? How can I be more effective in my coaching to enhance both the prompt quality and understanding of code generation? What collaborative tools and practices can enhance the coaching process within my team? How can consistent coaching lead to more efficient and accurate code generation, particularly when utilizing AI powered tools? "},{"id":7,"href":"/general/code-completion/","title":"Code Completion","section":"Generals","content":" Code Completion # Description # One of the simplest uses of GitHub Copilot is code completion. Code completion enhances developer productivity by offering potential code snippets as the developer is typing. For example, imagine defining a function in JavaScript. As you input the code below, GitHub Copilot will suggest potential code that could be used inside the function, such as the following code.\nExample # Input Code # function calculateSum(a, b) { // Enter your code here } Result Suggested by Copilot # function calculateSum(a, b) { // Enter your code here const sum = a + b; return sum; } Exerecise # Exercise 1: Complete the calculateSum(a, b) function by utilizing GitHub Copilot\u0026rsquo;s suggestions. Explore how different prompts or partial code inputs influence the suggestions made by Copilot. Checklist for Further Learning # Did your code output resemble the sample code provided? Is the outputted code robust? Is error handling considered? If not, how could you improve the code? What prompts or context can you add to write more precise code? "},{"id":8,"href":"/general/code-to-comment/","title":"Code to Comment","section":"Generals","content":" Code to Comment: Generating Comments from Code # Description # GitHub Copilot can generate comments from code. When existing code lacks sufficient comments, or to assist other developers in understanding the code, GitHub Copilot can automatically generate explanations in comment form. The following sample demonstrates the Sieve of Eratosthenes algorithm to list prime numbers less than a given number. While this code does not contain comments, GitHub Copilot can create comments to describe the code\u0026rsquo;s functionality.\nExample # Here\u0026rsquo;s the code without comments:\ndef eratosthenes_sieve(n): primes = [] sieve = [True] * (n + 1) for p in range(2, n + 1): if sieve[p]: primes.append(p) for i in range(p * p, n + 1, p): sieve[i] = False return primes Here\u0026rsquo;s how GitHub Copilot can add comments to explain it:\n# Write the description of the method here \u0026lt;- [Actual Prompt] # Input: n - the number of primes to return # Output: a list of the first n primes # Example: eratosthenes_sieve(5) -\u0026gt; [2, 3, 5, 7, 11] # Note: this is a very inefficient way to find primes, but it is easy to understand def eratosthenes_sieve(n): primes = [] sieve = [True] * (n + 1) for p in range(2, n + 1): if sieve[p]: primes.append(p) for i in range(p * p, n + 1, p): sieve[i] = False return primes Exercise # Exercise: Generate appropriate comments for the code at the top of the following function: def eratosthenes_sieve(n): primes = [] sieve = [True] * (n + 1) for p in range(2, n + 1): if sieve[p]: primes.append(p) for i in range(p * p, n + 1, p): sieve[i] = False return primes Checklist for Further Learning # Do the generated comments adequately explain the code\u0026rsquo;s functionality and algorithm? Are the comments helpful for other developers to understand the code? What do you think could be the reason for any incorrect comments that were generated? "},{"id":9,"href":"/general/code-to-document/","title":"Code to Document","section":"Generals","content":" Code to Document # Description # Chat-based AI tools can be used to automatically generate descriptions as well as longer texts such as documentation. For example, GitHub Copilot Chat can be leveraged to generate a full code synopsis, API documentation, and even output the entire code with it embedded within the code.\nSample Code # The following is a code snippet written for a Ruby on Rails Controller.\nclass RecipesController \u0026lt; ApplicationController before_action :set_recipe, only: [:show, :edit, :update, :destroy] # GET /recipes # GET /recipes.json def index @recipes = Recipe.all end # GET /recipes/1 # GET /recipes/1.json def show end # GET /recipes/new def new @recipe = Recipe.new end # GET /recipes/1/edit def edit end # POST /recipes # POST /recipes.json def create @recipe = Recipe.new(recipe_params) respond_to do |format| if @recipe.save format.html { redirect_to @recipe, notice: \u0026#39;Recipe was successfully created.\u0026#39; } format.json { render :show, status: :created, location: @recipe } else format.html { render :new } format.json { render json: @recipe.errors, status: :unprocessable_entity } end end end # PATCH/PUT /recipes/1 # PATCH/PUT /recipes/1.json def update respond_to do |format| if @recipe.update(recipe_params) format.html { redirect_to @recipe, notice: \u0026#39;Recipe was successfully updated.\u0026#39; } format.json { render :show, status: :ok, location: @recipe } else format.html { render :edit } format.json { render json: @recipe.errors, status: :unprocessable_entity } end end end # DELETE /recipes/1 # DELETE /recipes/1.json def destroy @recipe.destroy respond_to do |format| format.html { redirect_to recipes_url, notice: \u0026#39;Recipe was successfully destroyed.\u0026#39; } format.json { head :no_content } end end private # Use callbacks to share common setup or constraints between actions. def set_recipe @recipe = Recipe.find(params[:id]) end # Never trust parameters from the scary internet, only allow the white list through. def recipe_params params.require(:recipe).permit(:title, :instructions) end end Sample Result # Here is the specification document generated from the above Ruby code, displayed in markdown format.\n## RecipesController RecipesController provides operations for creating, viewing, editing, and deleting recipes, etc. ### Actions #### `index` - Description: Retrieves a list of recipes. - Method: GET - Path: `/recipes` - Response: List of recipes #### `show` - Description: Retrieves detailed information about a specific recipe. - Method: GET - Path: `/recipes/:id` - Parameter: `id` - Recipe\u0026#39;s ID - Response: Detailed information about the recipe #### `new` - Description: Displays the creation screen for a new recipe. - Method: GET - Path: `/recipes/new` #### `edit` - Description: Displays the editing screen for a specific recipe. - Method: GET - Path: `/recipes/:id/edit` - Parameter: `id` - Recipe\u0026#39;s ID #### `create` - Description: Creates a new recipe. - Method: POST - Path: `/recipes` - Parameter: `recipe` - Recipe information - Response: Detailed information about the created recipe #### `update` - Description: Updates a specific recipe. - Method: PATCH/PUT - Path: `/recipes/:id` - Parameters: `id` - Recipe\u0026#39;s ID, `recipe` - Information to update - Response: Detailed information about the updated recipe #### `destroy` - Description: Deletes a specific recipe. - Method: DELETE - Path: `/recipes/:id` - Parameter: `id` - Recipe\u0026#39;s ID - Response: Detailed information about the deleted recipe Exercise # Exercise 1: Utilize the provided Ruby code and experiment with generating different types of documentation, such as user manuals, API references, or code comments. Compare the differences and similarities. Exercise 2: Modify the Ruby code to include more complex functionalities, and then use GitHub Copilot Chat to generate the corresponding documentation. Analyze the generated documentation for accuracy and completeness. Exercise 3: Create a set of guidelines that would be important to follow when using AI tools like GitHub Copilot Chat for generating documentation. These guidelines should include considerations for clarity, accuracy, consistency, and maintainability. Checklist for Further Learning # Does the generated documentation appropriately describe each action and functionality of the code? Does the documentation clearly represent the specifications of the API? What should be taken into account when generating documentation from code? "},{"id":10,"href":"/general/comment-to-code/","title":"Comment to Code","section":"Generals","content":" Comment to Code Generation # Description # GitHub Copilot is capable of generating new code based on the specific text provided by a developer. By defining conditions in the form of comments, GitHub Copilot can create code that responds to the requirements.\nExample # Here\u0026rsquo;s a way to instruct GitHub Copilot to create a function through comments:\n// Function name: calculateAverage // Function arguments: numbers (array) // Return type of the function: number Based on these comments, Copilot might suggest the following code:\nfunction calculateAverage(numbers: number[]): number { // calculate the average of the array const sum = numbers.reduce((a, b) =\u0026gt; a + b); return sum / numbers.length; } Exerecise # Exercise 1: Write the comments to instruct Copilot to create a function that calculates the maximum number in an array. Use the following specification: // Function name: calculateMax // Function arguments: numbers (array) // Return type of the function: number Exercise 2: Test the generated function with different sets of numbers and verify if it returns the correct maximum value. Checklist for Further Learning # Is the generated code based on the specified conditions? Is the functionality of the code correctly implemented? What is the appropriate way to write comments for more complex condition definitions? To give more context, try using the OS dictation functionality as well as the keyboard. "},{"id":11,"href":"/design-pattern/consistent-coding-style/","title":"Consistent coding style","section":"Design-patterns","content":" Consistent coding style # Description # Consistent coding style is crucial in software development, as it not only enhances code readability but also leads to better suggestions from GitHub Copilot. Indentation, tabs, naming conventions, comment writing, language-specific abbreviations, and many other areas of coding style. By adhering to a uniform coding style and pattern, developers find it easier to follow excellent coding practices.\nExample # Here\u0026rsquo;s a positive example of using clear function names and following the codebase pattern using snake_case:\ndef calculate_area(length, width): return length * width Compare this with the inconsistent coding style below, where inappropriate function naming may lead to generic comments like \u0026ldquo;code goes here\u0026rdquo; from GitHub Copilot:\ndef calcSomething(l, w): # code goes here return Exercise # Exercise 1: Practice writing functions using descriptive and consistent naming conventions. Exercise 2: Analyze a code snippet and identify inconsistencies in coding style. Make necessary adjustments. Exercise 3: Utilize GitHub Copilot to create a small project, observing how it responds to different coding styles. Checklist for Further Learning # How does consistent coding style affect readability and maintainability of the codebase? What communication is needed to enforce coding standards within a team or project? How can GitHub Copilot assist in adhering to coding best practices? What behaviors does it promote or discourage? "},{"id":12,"href":"/design-pattern/context-less-architecture/","title":"Context-less Architecture","section":"Design-patterns","content":" Context-less Architecture # {% hint style=\u0026ldquo;info\u0026rdquo; %} Loosely coupled architectures themselves are also recommended in many cases, and this pattern is consistent with that idea. However, more discussion is needed to tie the context of AI Powered development to the broader architecture discussion and justify it. By all means, let the discussion begin. {% endhint %}\nDescription # Contextless architecture is a design pattern that limits coding to smaller, well-defined contexts within a system. By breaking complex programs into loosely coupled, independent components, this architecture improves maintainability, scalability, and flexibility.\nWhen working with AI tools like GitHub Copilot, it is essential to understand their nature and limitations. Currently GitHub Copilot is not AGI (Artificial General Intelligence) and therefore works best within a limited and precise context. By focusing on specific needs, developers can maximize Copilot\u0026rsquo;s accuracy and efficiency.\nThe key is to create a loosely coupled system where each component serves a specific purpose. This approach is consistent with the limitations of GitHub Copilot and allows developers to use the tool more effectively to build modular, robust software.\nOn the other hand, you should not design a system to fit the tools. This pattern is intended to more effectively speed up development by additionally considering the use of AI in development when it makes sense to be loosely coupled in real-world projects and products.\nExample # Before # Here, user management is mixed with authentication, making the context unclear and intertwined.\nclass UserManager: def create_user(self, username, password): # Code to create user pass def login(self, username, password): # Code to handle login pass def update_user_profile(self, user_id, profile_data): # Code to update user profile pass After # By applying Context-less Architecture, user management and authentication are separated into clear contexts.\nclass Authentication: def login(self, username, password): # Code to handle login pass class UserProfile: def update_profile(self, user_id, profile_data): # Code to update user profile pass These examples demonstrate the transformation from mixed, confusing contexts to clean, well-defined contexts by applying the Context-less Architecture pattern. This approach is especially beneficial when working with GitHub Copilot, considering its limitations in handling large and mixed contexts.\nWith this architecture, developers, and also GitHub Copilot, can focus on individual components, ensuring that the AI comprehends and accurately contributes to the code development.\nExercise # Exercise 1: Implement a small context-contained component using GitHub Copilot, and reflect on how limiting the context enhances its understanding. Exercise 2: Create a communication system between context-contained components with Copilot, evaluating its performance within confined contexts. Exercise 3: Review the overall architecture, considering the synergies and challenges with GitHub Copilot, and plan potential refinements. Checklist for Further Learning # How can I consistently apply the Context-less Architecture pattern with GitHub Copilot to achieve optimal results? What strategies can ensure that I provide the right context size to maximize Copilot\u0026rsquo;s accuracy? What might be the challenges in implementing this pattern across different projects, and how can I adapt accordingly? How can I continue to evolve and refine my use of Context-less Architecture with GitHub Copilot in various development scenarios? "},{"id":13,"href":"/client-tips/copilot-snippet-handling/","title":"Copilot Snippet Handling","section":"Client-tips","content":" Copilot Snippet Handling # {% hint style=\u0026ldquo;info\u0026rdquo; %} While this is accurate as of August 2023, the situation may change as GitHub Copilot and the LLM behind it evolve. Always try to get the most up-to-date information from GitHub. {% endhint %}\nDescription # GitHub Copilot, which utilizes OpenAI\u0026rsquo;s Large Language Models (LLM) to generate code, has a limitation on the number of tokens it can process. As of 2023, it doesn\u0026rsquo;t see all of the code that\u0026rsquo;s open in the editor and doesn\u0026rsquo;t receive every token. This means that users must carefully limit the context provided to GitHub Copilot. Notably, Copilot doesn\u0026rsquo;t have access to external repositories or source code placed in GitHub Enterprise Cloud.\nThe files that GitHub Copilot uses for suggestions are primarily the currently open file and other tab files adjacent to it (basically with the same file extension). To make accurate suggestions, it\u0026rsquo;s essential to have only the relevant files open. The following is a checklist as of August 2023. The types of files that GitHub Copilot includes as snippets may change in the future, but practices such as \u0026ldquo;closing unnecessary files\u0026rdquo; will likely have a positive impact on your coding even if you were not using GitHub Copilot.\nOpen the files you need to refer to Close unnecessary files If there is an .md file you want to refer to, copy it and comment it out Example # Consider a scenario where you have a Python function written in one tab and a similar function in an adjacent tab; GitHub Copilot can recognize patterns and suggest improvements.\n# tab 1 (adjacent) def add_numbers(a, b):. return a + b # tab 2 def subtract_numbers(a, b): return a - b return a - b answer = substruct_numbers(1, 2) + add_numbers( # \u0026lt;GitHub Copilot will suggest the code by reading the tab 1 \u0026gt; Exercise # Exercise 1: Experiment with reducing the code context sent to Copilot in a complex project. Observe how this affects the suggestions provided. Exercise 2: Discuss with your team the best practice for commenting based on language efficiency and understanding within the team. Checklist for Further Learning # What strategies can be employed to provide the necessary context to Copilot without exceeding token limitations? How does the choice of language in comments affect collaboration within a diverse team? "},{"id":14,"href":"/testing/creating-unit-tests/","title":"Creating unit tests","section":"Testings","content":" Creating Unit Tests # Description # Testing is a fundamental part of the software development process, ensuring that the code meets its design and behaves as intended. The creation of unit tests, which test individual components of the system, can be both challenging and time-consuming. With GitHub Copilot, this process becomes more streamlined. Let\u0026rsquo;s explore how a developer named Alice leverages GitHub Copilot to write unit tests for her application, reducing her workload and boosting her efficiency. This pattern is also applicable to functional and API testing.\nExample # Alice is working on a JavaScript function that needs to be thoroughly tested. With the help of GitHub Copilot, she can quickly generate the required unit tests.\nHere\u0026rsquo;s a simple function she wants to test:\nfunction add(x, y) { return x + y; } And here\u0026rsquo;s how she might create a unit test with Copilot\u0026rsquo;s assistance:\nconst assert = require(\u0026#39;assert\u0026#39;); describe(\u0026#39;add function\u0026#39;, () =\u0026gt; { it(\u0026#39;should add two numbers correctly\u0026#39;, () =\u0026gt; { assert.equal(add(2, 3), 5); }); }); Exercise # Exercise 1: Create a unit test for a function that multiplies two numbers using GitHub Copilot. Exercise 2: Utilize Copilot to create a suite of tests for various edge cases, such as handling null or undefined values. Exercise 3: Reflect on your current project. Identify a part of the code that lacks testing and create unit tests for it using Copilot. Checklist for Further Learning # How can you make sure you tests are comprehensive and cover all possible scenarios? What prompts do you add when GitHub Copilot does not cover a scenario at all? How is GitHub Copilot beneficial for other types of testing (E2E testing, integration testing, functional testing, etc.) and how can GitHub Copilot assist you in writing them? "},{"id":15,"href":"/design-pattern/eliminating-a-tiny-oss-dependency/","title":"Eliminating a tiny OSS dependency","section":"Design-patterns","content":" Eliminating a tiny OSS dependency # {% hint style=\u0026ldquo;info\u0026rdquo; %} This may be of limited applicability. As more cases are discovered, this maturity level will increase. {% endhint %}\nDescription # Do you know about the left-pad issue? In 2016, the left-pad library was suspended from npm, causing well-known libraries that depended on it to cease working. left-pad is a simple JavaScript library that only fills the left side of a string with a specified number of characters, or spaces if not specified. Excluding blank lines, it\u0026rsquo;s a simple code with only about 10 lines.\nThere are many ideas to avoid reinventing the wheel, On the other hand, we must also pay attention to external code that can have a significant impact. If the provided code\u0026rsquo;s scope is very limited, it might be better to contain it internally rather than depending on an external source.\nSamples # Implementing a left-pad function can be done as shown below:\ndef leftpad(string, length, char = \u0026#39; \u0026#39;) string.rjust(length, String(char)) end Exercise # Exercise 1: Implement the left-pad function that takes the string, length, and character to pad with. The default character should be a space. Exercise 2: Consider a scenario where multiple small external dependencies exist in a project. Identify a small utility function that can replace one such dependency and implement it. Checklist for Further Learning # Have you considered the trade-offs between using an external dependency and implementing the code yourself? How might this pattern of eliminating tiny dependencies affect the maintainability of the code? What principles or guidelines can be used to decide when to replace a tiny external dependency with an internal implementation? "},{"id":16,"href":"/client-tips/github-copilot-shortcuts/","title":"GitHub Copilot Shortcuts","section":"Client-tips","content":" GitHub Copilot Shortcuts # Description # GitHub Copilot provides developers with a set of keyboard shortcuts to accelerate the coding process. These shortcuts make the navigation and interaction with GitHub Copilot\u0026rsquo;s AI-driven suggestions more intuitive and efficient. In this pattern, we will explore the keyboard shortcuts that are essential for rapid code development with Copilot.\nExample # For example, to accept a suggestion from Copilot, you can simply press the TAB key. Here\u0026rsquo;s a list of some key shortcuts:\nAccept suggestion: TAB key Reject suggestion: Esc key Show combined suggestions: Ctrl + Enter key Accept at word level: Ctrl + Right Arrow key See next suggestion: Alt + ] key See previous suggestion: Alt + [ key Trigger inline suggestion: Alt + / key Show Labs feature list: Ctrl + Shift + Alt + e key Toggle sidebar: Ctrl + Shift+a key Exercise # Exercise 1: Try using the TAB key to accept a Copilot suggestion in your current project. How does it feel? Exercise 2: Press Esc key to reject a suggestion. What happens? Exercise 3: Use Ctrl + Enter key to see combined suggestions. Explore them and identify a useful one. Exercise 4: Navigate through the suggestions using Alt + ] and Alt + [ keys. How does it affect your code selection process? Exercise 5: Experiment with the other shortcuts listed above and describe your experience with each of them. Checklist for Further Learning # Have I internalized the shortcuts for accepting and rejecting Copilot suggestions? Am I comfortable using shortcuts to navigate through multiple suggestions? What other shortcuts within VSCode can enhance my coding experience with Copilot? How can I customize the shortcuts to suit my personal coding workflow? Could the use of these shortcuts help me in other coding environments or only in Visual Studio Code with Copilot? "},{"id":17,"href":"/client-tips/go-to-definition/","title":"Go to definition","section":"Client-tips","content":" Go to definition # {% hint style=\u0026ldquo;info\u0026rdquo; %} GitHub Copilot will not read all codebases as of August 2023, so there will be occasions when this technique will be necessary. On the other hand, there is a possibility that in the near future this technique will no longer be needed in GitHub Copilot, and this technique may be very limited. {% endhint %}\nDescription # When working with a complex codebase, jumping between files or searching through layers of code to find the definition of a particular symbol can be cumbersome. \u0026ldquo;Go to Definition\u0026rdquo; is a useful feature in Visual Studio Codethat allows developers to quickly navigate to the definition of a symbol in the current file. This not only enhances productivity but also enables better understanding of the code structure. GitHub Copilot will read open tabs. So, you can also pass relevant code snippets related to the symbol definition to GitHub Copilot\nExample # To use the \u0026ldquo;Go to Definition\u0026rdquo; feature in VS Code, simply right-click on the symbol you want to explore and select \u0026ldquo;Go to Definition.\u0026rdquo; You can also use the shortcut F12. Here\u0026rsquo;s how you can do it:\nExerecise # Exercise 1: Open a project with multiple files in Visual Studio Codeand try to use \u0026ldquo;Go to Definition\u0026rdquo; to navigate to a class or function definition. Exercise 2: Practice using the \u0026ldquo;Go to Definition\u0026rdquo; feature with different symbols such as variables, methods, or classes to understand its versatility. Checklist for Further Learning # How does the \u0026ldquo;Go to Definition\u0026rdquo; feature enhance your overall coding experience? How can GitHub Copilot\u0026rsquo;s integration with the \u0026ldquo;Go to Definition\u0026rdquo; feature be used to further assist you in code navigation and understanding? Can you identify situations where this feature could be exceptionally useful in your development workflow? "},{"id":18,"href":"/design-pattern/high-level-architecture-first/","title":"High-level Architecture First","section":"Design-patterns","content":" High-level Architecture First # Description # When developing a complex system, it is common to dive into the details of the code and lose sight of the overall architecture of the program. When this happens repeatedly, GitHub Copilot also loses sight of its overall architecture. This can lead to misunderstandings and errors. By designing the high-level architecture of the program first and commenting on the function and purpose of each piece of code during development, GitHub Copilot can better understand the context and make more precise suggestions.\nSamples # Consider an API endpoint file in a web application. Suggesting the design in natural language early on will help GitHub Copilot understand the functionality of each endpoint.\n# GET /items # - Retrieves a list of items. # - Returns a collection of items in the response. # # POST /items # - Creates a new item and adds it to the collection. # - Expects item parameters in the request. # - Redirects to the cart page with a success message upon success. # - Displays the form for a new item if failed. # # GET /items/:id # - Retrieves an item with a specific ID. # - Expects the item\u0026#39;s ID as a URL parameter. # - Returns the requested item\u0026#39;s details in the response. # ... Exercise # Exercise: Create an outline of the high-level architecture for a login and registration system, including comments for each endpoint. Checklist for Further Learning # Have you established a clear roadmap before writing code details? Does GitHub Copilot understand the purpose of a file just by reading the high-level comments? Are you applying this pattern consistently throughout your codebase? "},{"id":19,"href":"/general/language-translation/","title":"Language Translation","section":"Generals","content":" Language Translation # Description # Sometimes, developers may need to translate code from one language to another, such as from Python to JavaScript or HTML to Markdown. This is where GitHub Copilot shines as a virtual aide. Imagine a scenario where a team is working on a multi-platform project, and they need to quickly convert a Python algorithm into JavaScript for web integration. GitHub Copilot\u0026rsquo;s Language Translation ability can save hours of manual translation, enabling seamless cross-language development.\nExample # Here\u0026rsquo;s an example of translating a Python function into JavaScript:\nPython code:\ndef add(a, b): return a + b Using GitHub Copilot, we can effortlessly translate it into JavaScript:\nfunction add(a, b) { return a + b; } Exercise # Exercise 1: Translate a simple HTML structure into Markdown using GitHub Copilot. Exercise 2: Convert a given Python class into its equivalent Java representation. Exercise 3: Write a C# function and then translate it into Ruby using GitHub Copilot. Checklist for Further Learning # How can GitHub Copilot be further optimized to provide more accurate translations between specific languages? What are the limitations, if any, when translating code from one language to another with GitHub Copilot? How can I utilize GitHub Copilot in collaborative environments to make cross-language projects more efficient? What are the differences between using GitHub Copilot and GitHub Copilot Chat? "},{"id":20,"href":"/refactoring/making-the-calculation-part-independent/","title":"Making the calculation part independent","section":"Refactorings","content":" Making the Calculation Part Independent # Description # In the rapidly evolving world of software development, relying on tools like GitHub Copilot can enhance the development process. However, current versions of large language models may have limitations when handling complex calculations. To address this, developers can refactor their code by moving the computation part to another function. This improves code maintainability, readability, and makes it easier to test and develop with AI tools. Imagine a developer building a financial software system who needs to separate interest calculations from the user interface logic. Every time GitHub Copilot rewrites a particular piece of code, verifying that the logic is correct is a very cumbersome task. By separating this complex computation, you create a codebase that can work with a flexible and more durable AI.\nExample # Calculating and Handling Order Totals\nBefore, when the calculation logic was mixed with other functionalities:\ndef handle_order(order_items): tax_rate = 0.05 total = 0 for item in order_items: total += item[\u0026#39;price\u0026#39;] total += total * tax_rate process_payment(total) ship_order(order_items) return total After, when the calculation logic is completely separated from other functionalities:\ndef calculate_total(order_items, tax_rate=0.05): subtotal = sum(item[\u0026#39;price\u0026#39;] for item in order_items) total = subtotal + (subtotal * tax_rate) return total def handle_order(order_items): total = calculate_total(order_items) process_payment(total) ship_order(order_items) return total Here, the calculate_total function takes care of all the calculations related to the order total, while the handle_order function handles other related functionalities, such as processing payment and shipping the order.\nExerecise # Exercise 1: Identify a portion of code in your project where the calculation logic is mixed with other functionalities and refactor it using the pattern described above. Exercise 2: Write tests for both the calculation part and the non-calculation part to ensure that they function as intended independently. Checklist for Further Learning # How can I identify other areas in my codebase where the calculation logic can be isolated? What strategies can I employ to ensure that the separation of calculation logic doesnâ€™t introduce new errors or complexities? How does this separation align with the broader architecture and design principles of my application? "},{"id":21,"href":"/general/object-generation-from-structured-data/","title":"Object Generation from Structured Data","section":"Generals","content":" Object Generation from Structured Data # Description # Working with structured data is an everyday task for developers. Transforming data from formats like JSON into objects within your programming language allows for more robust and maintainable code. Imagine you have a list of users, and you want to convert this data into user objects within your application. GitHub Copilot can help you in this transformation process, turning a tedious task into a seamless exercise.\nExample # Here\u0026rsquo;s a Python example of how you might convert the given JSON data into a list of user objects:\nimport json json_data = \u0026#39;[{\u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Yuki Hattori\u0026#34;}, {\u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;George Hattori\u0026#34;}]\u0026#39; users = json.loads(json_data) class User: def __init__(self, id, name): self.id = id self.name = name user_objects = [User(user[\u0026#39;id\u0026#39;], user[\u0026#39;name\u0026#39;]) for user in users] for user in user_objects: print(user.id, user.name) Exercise # Exercise 1: Try generating objects from a different JSON structure, e.g., a JSON that includes address information for the users. Exercise 2: Experiment with handling edge cases, such as missing data within the JSON, and ensure that your code handles them gracefully. Checklist for Further Learning # How would you modify the code to accommodate a more complex data structure? What methods could you use to validate the data before transforming it into objects? How can this pattern be adapted to different programming languages or frameworks? "},{"id":22,"href":"/client-tips/pin-the-file-you-need/","title":"Pin the files you need","section":"Client-tips","content":" Pin the files you need # Description # The effectiveness of GitHub Copilot depends on the context provided to it. GitHub Copilot searches through open tabs by text similarity, sending snippets to the Large Language Model (LLM), which itself is a complete black box. Therefore, we must be mindful of the context we want to provide. In programming, files such as declaration files (d.ts), test files, and interface files contain a wealth of context information. By using Visual Studio Code\u0026rsquo;s pinning feature, you can easily access these files when needed and provide information to GitHub Copilot more efficiently.\nExample # Here\u0026rsquo;s how you can pin a file in Visual Studio Code:\nOpen the file you want to pin. Right-click on the file tab. Select \u0026ldquo;Pin Tab\u0026rdquo; from the context menu. Exerecise # Exercise 1: Pin a declaration file (such as a .d.ts file) in your current project and notice how it\u0026rsquo;s easier to access when working with GitHub Copilot. Exercise 2: Create a new interface file and pin it. Explore how GitHub Copilot can utilize this file for better code suggestions. Exercise 3: Pin multiple test files within your project and observe how this helps you when writing new test cases with the assistance of Copilot. Checklist for Further Learning # How might pinning different types of files affect your workflow with GitHub Copilot? What other features of Visual Studio Code could be leveraged to enhance your experience with GitHub Copilot? How can you manage a large number of pinned files to ensure that the right context is always available for Copilot? "},{"id":23,"href":"/general/quick-qna/","title":"Quick Q\u0026A","section":"Generals","content":" Quick Q\u0026amp;A : A Technique for Fast Interaction with Copilot # Description # In the collaborative coding environment, quick interactions and clarifications are often key to efficient development. While GitHub has the \u0026ldquo;GitHub Copilot Chat\u0026rdquo; product for more structured and extensive conversations, the \u0026ldquo;Quick Q\u0026amp;A\u0026rdquo; technique serves as a lightweight alternative. It enables developers to rapidly engage with Copilot in the code editor for brief one-liner answers and insights. It\u0026rsquo;s not a distinct feature but a method that leverages commenting for quick interactions with Copilot, making it an agile and handy tool for on-the-spot guidance.\nExample # Using the Quick Chat technique, you can pose questions directly in your code and get brief responses from Copilot:\n# me: What\u0026#39;s the best way to optimize this loop? # copilot: Then GitHub Copilot will answer to the question\n# me: What\u0026#39;s the best way to optimize this loop? # copilot: Consider using a vectorized approach or caching intermediate results. It can be just \u0026ldquo;q:\u0026rdquo; and \u0026ldquo;a:\u0026rdquo;\n// q: How do I get the current time in milliseconds? // a: For more context-based dialogue, roles can be defined:\n# Roles: copilot # Expert in Python with 15+ years of experience # Role: me # Mid-level engineer # # me: What\u0026#39;s the best way to optimize this loop? # copilot: Consider using a vectorized approach or caching intermediate results. Exercise # Exercise 1: Compare Quick Chat with \u0026ldquo;copilot chat\u0026rdquo; by engaging with both and noting the differences. Exercise 2: Use Quick Chat to get one-liner answers to three different coding questions. Exercise 3: Define roles within Quick Chat and observe how contextual information affects Copilot\u0026rsquo;s responses. Checklist for Further Learning # How does Quick Chat differ from the \u0026ldquo;copilot chat\u0026rdquo; product, and when might one be preferred over the other? How can the Quick Chat technique be integrated into various stages of the development process? What are the potential drawbacks or limitations of using Quick Chat, and how might they be mitigated? "},{"id":24,"href":"/general/regular-expression/","title":"Regular Expression","section":"Generals","content":" Regular Expression # {% hint style=\u0026ldquo;info\u0026rdquo; %} Currently, LLMs do not have the ability to properly represent complex regular expressions. For complex ones, a human must provide supplemental input. On the other hand, it can be applied to simple regular expressions. {% endhint %}\nDescription # GitHub Copilot can create a draft of regular expression patterns. Below, we\u0026rsquo;ll explain how to use regular expressions to search or extract strings. Two examples illustrate how GitHub Copilot can generate regular expressions through both input-output pattern and natural language pattern.\nExample # Input and Output Pattern # Sample Code # First, by writing the input and output, GitHub Copilot can create the regular expression pattern:\nimport re # Write a regular expression # - Input: \u0026#34;Hello World\u0026#34; # - Output: [\u0026#34;H\u0026#34;, \u0026#34;W\u0026#34;] regex Sample Result # import re # Write a regular expression # - Input: \u0026#34;Hello World\u0026#34; # - Output: [\u0026#34;H\u0026#34;, \u0026#34;W\u0026#34;] regex = r\u0026#34;[A-Z]\u0026#34; matched = re.findall(regex, \u0026#34;Hello World\u0026#34;) Natural Language Pattern # Second, by providing what you want to achieve with the regular expression in natural language:\nSample Code # import re # Write a regular expression # - \u0026#34;I have 3 apples and 2 oranges\u0026#34; like string, extract only the numbers to make an array sentence Sample Result # import re # Write a regular expression # - \u0026#34;I have 3 apples and 2 oranges\u0026#34; like string, extract only the numbers to make an array sentence = \u0026#34;I have 3 apples and 2 oranges\u0026#34; regex = r\u0026#34;\\d+\u0026#34; matched = re.findall(regex, sentence) Exercise # Exercise 1: Extract only the lowercase letters from the string \u0026ldquo;Hello World.\u0026rdquo; Checklist for Further Learning # Are the regular expression patterns extracting the exact matches from the given strings? Currently, LLMs like GitHub Copilot do not have the ability to properly represent complex regular expressions. What would you do if you want to represent a complex regular expression? How would you leverage GitHub Copilot to support and assist you in building it? "},{"id":25,"href":"/general/showing-examples/","title":"Showing Examples","section":"Generals","content":" Showing Examples # Description # Using GitHub Copilot, developers can generate code based on provided examples. This can be incredibly useful when you expect the code that produces a specific output. In this pattern, we\u0026rsquo;ll explore how to create a Ruby on Rails model from a given example, such as generating JSON.\nExample # The following sample illustrates how you can provide an example in comments and ask GitHub Copilot to generate Ruby on Rails code to create the corresponding model.\n# Example of code generation to create the following JSON: # { # \u0026#34;name\u0026#34;: \u0026#34;John Smith\u0026#34;, # \u0026#34;age\u0026#34;: 30, # \u0026#34;description\u0026#34;: \u0026#34;This is a sample description.\u0026#34;, # \u0026#34;country\u0026#34;: \u0026#34;Japan\u0026#34;, # \u0026#34;title\u0026#34;: \u0026#34;Customer Success Architect\u0026#34;, # \u0026#34;email\u0026#34;: \u0026#34;johnsmith@example.com\u0026#34; # } rails g model users name:string age:integer description:text country:string title:string email:string Exercise # Exercise 1: Based on the following example, generate the Ruby on Rails code to create a model for books. { \u0026#34;title\u0026#34;: \u0026#34;Book\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Jane Doe\u0026#34;, \u0026#34;price\u0026#34;: 19.99 } Exercise 2: Experiment with different attributes and types in the JSON example, then generate the corresponding Rails code. Exercise 3: Test the generated code in a Rails project to ensure that it creates the expected model. Checklist for Further Learning # Does the generated code accurately reflect the given example, creating the appropriate Ruby on Rails code? What were the key considerations or challenges when generating code from the provided example? How can you further customize or optimize the generated code to suit specific project requirements? "},{"id":26,"href":"/testing/specify-test-valiation/","title":"Specify how to generate test code","section":"Testings","content":" Specify How to Generate Test Code # Description # When it comes to testing, specific instructions can be a great way to make sure you\u0026rsquo;re covering all the necessary scenarios. Instead of giving vague instructions like \u0026ldquo;add unit tests,\u0026rdquo; you can provide concrete details about the testing frameworks and the number of cases you want to generate. This can be helpful in utilizing tools like GitHub Copilot, where specifying \u0026ldquo;use Junit and Mockito to add unit tests, testing at least 10 variations of valid and invalid input combinations\u0026rdquo; can yield a more accurate and comprehensive result.\nExample # If you are aiming to generate a test code using Junit and Mockito, you can provide the following prompt to GitHub Copilot:\n// Using Junit and Mockito, add unit tests // Test at least 10 variations of valid and invalid input combinations @Test public void validateInput() { // Your code here } Exercise # Exercise 1: Write a unit test using JUnit that tests a simple method with 3 different valid inputs. Exercise 2: Extend the unit test to include 3 different invalid inputs, and verify that exceptions are handled correctly. Checklist for Further Learning # How can you ensure that the tests cover all the critical paths in the code? Can you write the test code so that the test always fails? What strategies can be used to maintain the tests as the codebase evolves? "},{"id":27,"href":"/testing/test-only-what-is-necessary/","title":"Test only what is necessary","section":"Testings","content":" Test Only What is Necessary # {% hint style=\u0026ldquo;info\u0026rdquo; %} There is no need to write unnecessary test cases, but it depends on the team what tests are needed. More specific discussion is needed to flesh this out as a pattern. {% endhint %}\nDescription # In the era of rapid software development, writing efficient and useful tests is more important than ever, and when using GitHub Copilot, developers may generate a lot of test code to increase coverage. However, unnecessary test code generation can lead to maintenance burdens and technical debt, so it is important to test only what is necessary when writing test code using GitHub Copilot.\nExample # Here\u0026rsquo;s an example of how you might choose to write a meaningful test for a specific function rather than writing multiple tests just to boost coverage:\nHere are some examples of possible unnecessary test codes:\nTesting Setters and Getters Testing Language Features Testing Framework Functionality Testing Constants Redundant Tests with Same Logic Testing Trivial Logic Testing Third-party Libraries Testing Random Values Without Logic Rather than adding numerous tests that only increase coverage without adding value.\nExerecise # Exercise 1: Identify a function in your codebase that is currently over-tested with meaningless tests and refactor it to only include necessary tests. Exercise 2: Write a new test for a critical part of your code, focusing only on the crucial aspects, avoiding redundancy. Exercise 3: Evaluate your current test coverage and identify areas where tests can be reduced without losing essential coverage. Checklist for Further Learning # Are you writing tests that truly validate the functionality, or am I writing tests just to increase coverage? How can you ensure that the tests I\u0026rsquo;m writing are providing value to the project and not just adding to the maintenance burden? What strategies can you adopt to keep my test suite lean and meaningful, especially when using tools like GitHub Copilot? "},{"id":28,"href":"/general/type-hinting/","title":"Type Hinting","section":"Generals","content":" Type Hinting # Description # In the world of dynamic typing programming languages, developers often face challenges in understanding code, especially when working on complex systems. Type hinting adds a layer of clarity by explicitly declaring the expected data types. With GitHub Copilot, the integration of type hinting can increase the accuracy of code suggestions, empowering developers and GitHub Copilot to write code more efficiently.\nImagine you\u0026rsquo;re working on a project where functions are deeply nested, and tracking the types of variables becomes convoluted. Integrating type hinting also makes the code more readable for your fellow developers.\nExample # Here\u0026rsquo;s how you can define a function with type hints in Python:\ndef add_numbers(a: int, b: int) -\u0026gt; int: return a + b Copilot will recognize these type hints and generate code suggestions accordingly.\nExerecise # Exercise 1: Write a function that takes two string parameters and returns their concatenation, using type hints. Exercise 2: Convert an existing piece of code in your project to include type hints, and observe the difference in Copilot\u0026rsquo;s suggestions. Exercise 3: Create a complex class with multiple methods and use type hinting for all the parameters and return types. Checklist for Further Learning # Are you using type hints consistently throughout my codebase? Have I considered the potential drawbacks of overusing type hinting, and how do I find the right balance in my code? "},{"id":29,"href":"/design-pattern/working-on-small-chunk/","title":"Working on small chunks","section":"Design-patterns","content":" Working on Small Chunks # Description # Working on small chunks of code with less context can lead to improved Copilot\u0026rsquo;s output. Imagine you\u0026rsquo;re building a complex application with several interconnected components. Instead of trying to generate everything in one go, you break down the task into smaller parts, providing a confined context for Copilot. This approach not only streamlines the development process but also enhances the quality of the generated code.\nSome ideas consider context-less architecture in the design phase, but it is difficult to apply a loosely coupled architecture to every project.\nAlso, changing the architectural design to improve the accuracy of AI tools is not the way to go. This pattern aims to improve GitHub Copilot\u0026rsquo;s proposal by at least working in small chunks so that the context is as small as possible in the working environment, so that GitHub Copilot does not become overwhelmed by the complexity of the overall project. more controlled, accurate, and efficient code generation that allows you to understand the specific tasks of the clues.\nExample # Suppose you want to write a function to calculate the factorial of a number. Instead of asking Copilot for the entire solution, you may start by writing the function signature and then ask for the body:\ndef factorial(n): # Ask Copilot to complete this function Exerecise # Exercise 1: Break down a complex algorithm into smaller parts and use Copilot to generate code for each part. Exercise 2: Write a high-level description of a task, and then ask Copilot for code in a narrow context. Compare the results. Exercise 3: Reflect on your personal development process and identify areas where breaking tasks into smaller chunks can be beneficial. Checklist for Further Learning # How can narrowing down the context impact the relevancy of Copilot\u0026rsquo;s suggestions? What strategies can be used to provide Copilot with a more precise context for better code generation? How does Copilot\u0026rsquo;s probabilistic nature influence its ability to generate code in different scenarios? In what situations might working in smaller chunks with Copilot be less effective or more challenging? "},{"id":30,"href":"/testing/writing-failure-case-first/","title":"Writing failure case first","section":"Testings","content":" Writing Failure Case First # {% hint style=\u0026ldquo;info\u0026rdquo; %} While this is important in development, it is necessary to find best practices on how this can be a generic pattern in many cases and how to get GitHub Copilot to suggest test cases appropriately. {% endhint %}\nDescription # In a development cycle, writing test cases is an essential aspect. When working with GitHub Copilot, it becomes even more convenient as it reads your implementation and generates test cases accordingly. While GitHub Copilot is very effective in generating success cases, it\u0026rsquo;s vital not to overlook the failure cases. Considering failure cases first can lead to more robust code.\nExample # To demonstrate the importance of this, consider a function that divides two numbers. GitHub Copilot might suggest a test case that covers the happy path. But what about when the denominator is zero?\ndef divide(a, b): return a / b # Failure test case def test_divide_by_zero(): # \u0026lt;YOUR CODE AND GITHUB COPILOT SUGGESTION HEERE\u0026gt; Exerecise # Exercise 1: Write a function that multiplies two numbers and include both successful and failure test cases (consider edge cases like multiplying large numbers). Exercise 2: Analyze an existing piece of code in your project and identify any missing failure test cases. Write these test cases and ensure they pass. Exercise 3: Implement a failure-first approach in your next project, writing the failure test cases before the actual implementation, and reflect on how this impacts your development process. Checklist for Further Learning # Have you considered all potential failure cases in recent code? Do you consistently include failure test cases in your test suite? How can you encourage your team to adopt a TDD mindset in creating test cases? "},{"id":31,"href":"/testing/writing-test-cases-in-natural-language-first/","title":"Writing test cases in natural language first","section":"Testings","content":" Writing Test Cases in Natural Language First # Description # When working with AI-powered code generation, like GitHub Copilot, expecting comprehensive test coverage without providing clear context to the AI is challenging. Instead of trying to write the test cases in code at that point, create natural language descriptions first. This will focus on improving the test coverage, ensuring that the generated code meets all the necessary criteria.\nExample # Here\u0026rsquo;s an example of how you can write test cases in natural language for a multiplication function. This practice ensures that you cover various scenarios and edge cases before generating the code.\nclass TestMultiply(unittest.TestCase): def test_multiply(self): # Tests for different cases, such as positive, negative, zero, decimal, and non-integer inputs Exercise # Exercise 1: Write natural language test cases for a function that calculates the area of a triangle. Consider different input scenarios and edge cases. Exercise 2: Use GitHub Copilot to generate code from the natural language test cases you wrote in Exercise 1. Analyze the results. Exercise 3: Create a test suite using natural language for a more complex function, like a sorting algorithm. Consider various input scenarios and edge cases. Checklist for Further Learning # What are the benefits of writing test cases in natural language before coding? How can natural language test cases improve collaboration between developers and non-technical stakeholders? What are the potential challenges of using this approach, and how might they be mitigated? "},{"id":32,"href":"/refactoring/writing-test-code-before-refactoring/","title":"Writing test code before refactoring","section":"Refactorings","content":" Writing test code before refactoring # Description # In the modern world of software development, refactoring can be seen as a fun and engaging task, especially with tools like GitHub Copilot at your disposal. It\u0026rsquo;s so easy to dive in and make changes, but without proper tests, even the most promising code modification can lead to unexpected results. This pattern emphasizes the importance of writing tests before refactoring code to ensure that the functionality remains consistent. Think of tests as your safety net; they catch the problems before they become catastrophic.\nExample # Suppose you have a function that calculates the total price of a shopping cart, and you want to refactor it for better clarity. Here\u0026rsquo;s the original code:\ndef total_price(items): return sum(item[\u0026#39;price\u0026#39;] * item[\u0026#39;quantity\u0026#39;] for item in items) Before refactoring, write tests to ensure that the existing functionality is preserved:\ndef test_total_price(): items = [ {\u0026#39;price\u0026#39;: 5, \u0026#39;quantity\u0026#39;: 2}, {\u0026#39;price\u0026#39;: 3, \u0026#39;quantity\u0026#39;: 1} ] assert total_price(items) == 13 Now you can refactor the code to make it more readable:\ndef total_price(items): total = 0 for item in items: total += item[\u0026#39;price\u0026#39;] * item[\u0026#39;quantity\u0026#39;] return total The test still passes, ensuring that your refactoring didn\u0026rsquo;t change the expected outcome.\nExercise # Exercise 1: Write a function that needs refactoring and then write corresponding tests for it. Exercise 2: Refactor the function while ensuring that the tests still pass. Exercise 3: Simulate a failure by making an incorrect change in the refactored function and observe how the test helps in catching the error. Checklist for Further Learning # How can you make sure that your tests are covering all the important aspects of the code? What tools and frameworks are available in your language of choice to help write and run tests? How can the practice of Test-Driven Development (TDD) be applied when refactoring? How does it differ from writing tests after the code is written? What are the best practices for organizing your tests? How can they be maintained and updated as the code evolves? "}]